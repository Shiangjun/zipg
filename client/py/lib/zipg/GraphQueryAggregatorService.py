#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport


class Iface(object):
    def init(self):
        pass

    def connect_to_aggregators(self):
        pass

    def disconnect_from_aggregators(self):
        pass

    def shutdown(self):
        pass

    def record_edge_updates(self, next_shard, local_shard, updates):
        """
        Parameters:
         - next_shard
         - local_shard
         - updates
        """
        pass

    def record_node_append(self, next_shard, local_shard, obj):
        """
        Parameters:
         - next_shard
         - local_shard
         - obj
        """
        pass

    def get_attribute(self, nodeId, attrId):
        """
        Parameters:
         - nodeId
         - attrId
        """
        pass

    def get_attribute_local(self, shardId, nodeId, attrId):
        """
        Parameters:
         - shardId
         - nodeId
         - attrId
        """
        pass

    def get_neighbors(self, nodeId):
        """
        Parameters:
         - nodeId
        """
        pass

    def get_neighbors_local(self, shardId, nodeId):
        """
        Parameters:
         - shardId
         - nodeId
        """
        pass

    def get_neighbors_atype(self, nodeId, atype):
        """
        Parameters:
         - nodeId
         - atype
        """
        pass

    def get_neighbors_atype_local(self, shardId, nodeId, atype):
        """
        Parameters:
         - shardId
         - nodeId
         - atype
        """
        pass

    def get_neighbors_attr(self, nodeId, attrId, attrKey):
        """
        Parameters:
         - nodeId
         - attrId
         - attrKey
        """
        pass

    def get_neighbors_attr_local(self, shardId, nodeId, attrId, attrKey):
        """
        Parameters:
         - shardId
         - nodeId
         - attrId
         - attrKey
        """
        pass

    def get_nodes(self, attrId, attrKey):
        """
        Parameters:
         - attrId
         - attrKey
        """
        pass

    def get_nodes_local(self, attrId, attrKey):
        """
        Parameters:
         - attrId
         - attrKey
        """
        pass

    def get_nodes2(self, attrId1, attrKey1, attrId2, attrKey2):
        """
        Parameters:
         - attrId1
         - attrKey1
         - attrId2
         - attrKey2
        """
        pass

    def get_nodes2_local(self, attrId1, attrKey1, attrId2, attrKey2):
        """
        Parameters:
         - attrId1
         - attrKey1
         - attrId2
         - attrKey2
        """
        pass

    def filter_nodes_local(self, nodeIds, attrId, attrKey):
        """
        Parameters:
         - nodeIds
         - attrId
         - attrKey
        """
        pass

    def get_edge_attrs(self, nodeId, atype):
        """
        Parameters:
         - nodeId
         - atype
        """
        pass

    def get_edge_attrs_local(self, shardId, nodeId, atype):
        """
        Parameters:
         - shardId
         - nodeId
         - atype
        """
        pass

    def assoc_range(self, src, atype, off, len):
        """
        Parameters:
         - src
         - atype
         - off
         - len
        """
        pass

    def assoc_range_local(self, shardId, src, atype, off, len):
        """
        Parameters:
         - shardId
         - src
         - atype
         - off
         - len
        """
        pass

    def assoc_count(self, src, atype):
        """
        Parameters:
         - src
         - atype
        """
        pass

    def assoc_count_local(self, shardId, src, atype):
        """
        Parameters:
         - shardId
         - src
         - atype
        """
        pass

    def assoc_get(self, src, atype, dstIdSet, tLow, tHigh):
        """
        Parameters:
         - src
         - atype
         - dstIdSet
         - tLow
         - tHigh
        """
        pass

    def assoc_get_local(self, shardId, src, atype, dstIdSet, tLow, tHigh):
        """
        Parameters:
         - shardId
         - src
         - atype
         - dstIdSet
         - tLow
         - tHigh
        """
        pass

    def obj_add(self, attrs):
        """
        Parameters:
         - attrs
        """
        pass

    def obj_get(self, nodeId):
        """
        Parameters:
         - nodeId
        """
        pass

    def obj_get_local(self, shardId, nodeId):
        """
        Parameters:
         - shardId
         - nodeId
        """
        pass

    def assoc_time_range(self, src, atype, tLow, tHigh, limit):
        """
        Parameters:
         - src
         - atype
         - tLow
         - tHigh
         - limit
        """
        pass

    def assoc_time_range_local(self, shardId, src, atype, tLow, tHigh, limit):
        """
        Parameters:
         - shardId
         - src
         - atype
         - tLow
         - tHigh
         - limit
        """
        pass

    def assoc_add(self, src, atype, dst, time, attr):
        """
        Parameters:
         - src
         - atype
         - dst
         - time
         - attr
        """
        pass

    def getNode(self, id):
        """
        Parameters:
         - id
        """
        pass

    def getNodeLocal(self, shard_id, id):
        """
        Parameters:
         - shard_id
         - id
        """
        pass

    def addNode(self, id, data):
        """
        Parameters:
         - id
         - data
        """
        pass

    def deleteNode(self, id):
        """
        Parameters:
         - id
        """
        pass

    def deleteNodeLocal(self, shard_id, id):
        """
        Parameters:
         - shard_id
         - id
        """
        pass

    def updateNode(self, id, data):
        """
        Parameters:
         - id
         - data
        """
        pass

    def getLink(self, id1, link_type, id2):
        """
        Parameters:
         - id1
         - link_type
         - id2
        """
        pass

    def getLinkLocal(self, shard_id, id1, link_type, id2):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
         - id2
        """
        pass

    def addLink(self, link):
        """
        Parameters:
         - link
        """
        pass

    def deleteLink(self, id1, link_type, id2):
        """
        Parameters:
         - id1
         - link_type
         - id2
        """
        pass

    def deleteLinkLocal(self, shard_id, id1, link_type, id2):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
         - id2
        """
        pass

    def updateLink(self, link):
        """
        Parameters:
         - link
        """
        pass

    def getLinkList(self, id1, link_type):
        """
        Parameters:
         - id1
         - link_type
        """
        pass

    def getLinkListLocal(self, shard_id, id1, link_type):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
        """
        pass

    def getFilteredLinkList(self, id1, link_type, min_timestamp, max_timestamp, offset, limit):
        """
        Parameters:
         - id1
         - link_type
         - min_timestamp
         - max_timestamp
         - offset
         - limit
        """
        pass

    def getFilteredLinkListLocal(self, shard_id, id1, link_type, min_timestamp, max_timestamp, offset, limit):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
         - min_timestamp
         - max_timestamp
         - offset
         - limit
        """
        pass

    def countLinks(self, id1, link_type):
        """
        Parameters:
         - id1
         - link_type
        """
        pass

    def rpq(self, query):
        """
        Parameters:
         - query
        """
        pass

    def path_query(self, query):
        """
        Parameters:
         - query
        """
        pass

    def path_query_local(self, query):
        """
        Parameters:
         - query
        """
        pass

    def advance_path_query_ctx(self, query, ctx):
        """
        Parameters:
         - query
         - ctx
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def init(self):
        self.send_init()
        return self.recv_init()

    def send_init(self):
        self._oprot.writeMessageBegin('init', TMessageType.CALL, self._seqid)
        args = init_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_init(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = init_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "init failed: unknown result")

    def connect_to_aggregators(self):
        self.send_connect_to_aggregators()
        return self.recv_connect_to_aggregators()

    def send_connect_to_aggregators(self):
        self._oprot.writeMessageBegin('connect_to_aggregators', TMessageType.CALL, self._seqid)
        args = connect_to_aggregators_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connect_to_aggregators(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connect_to_aggregators_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "connect_to_aggregators failed: unknown result")

    def disconnect_from_aggregators(self):
        self.send_disconnect_from_aggregators()
        self.recv_disconnect_from_aggregators()

    def send_disconnect_from_aggregators(self):
        self._oprot.writeMessageBegin('disconnect_from_aggregators', TMessageType.CALL, self._seqid)
        args = disconnect_from_aggregators_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disconnect_from_aggregators(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disconnect_from_aggregators_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def shutdown(self):
        self.send_shutdown()
        self.recv_shutdown()

    def send_shutdown(self):
        self._oprot.writeMessageBegin('shutdown', TMessageType.CALL, self._seqid)
        args = shutdown_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shutdown(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shutdown_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def record_edge_updates(self, next_shard, local_shard, updates):
        """
        Parameters:
         - next_shard
         - local_shard
         - updates
        """
        self.send_record_edge_updates(next_shard, local_shard, updates)
        self.recv_record_edge_updates()

    def send_record_edge_updates(self, next_shard, local_shard, updates):
        self._oprot.writeMessageBegin('record_edge_updates', TMessageType.CALL, self._seqid)
        args = record_edge_updates_args()
        args.next_shard = next_shard
        args.local_shard = local_shard
        args.updates = updates
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_record_edge_updates(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = record_edge_updates_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def record_node_append(self, next_shard, local_shard, obj):
        """
        Parameters:
         - next_shard
         - local_shard
         - obj
        """
        self.send_record_node_append(next_shard, local_shard, obj)
        self.recv_record_node_append()

    def send_record_node_append(self, next_shard, local_shard, obj):
        self._oprot.writeMessageBegin('record_node_append', TMessageType.CALL, self._seqid)
        args = record_node_append_args()
        args.next_shard = next_shard
        args.local_shard = local_shard
        args.obj = obj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_record_node_append(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = record_node_append_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_attribute(self, nodeId, attrId):
        """
        Parameters:
         - nodeId
         - attrId
        """
        self.send_get_attribute(nodeId, attrId)
        return self.recv_get_attribute()

    def send_get_attribute(self, nodeId, attrId):
        self._oprot.writeMessageBegin('get_attribute', TMessageType.CALL, self._seqid)
        args = get_attribute_args()
        args.nodeId = nodeId
        args.attrId = attrId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_attribute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_attribute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_attribute failed: unknown result")

    def get_attribute_local(self, shardId, nodeId, attrId):
        """
        Parameters:
         - shardId
         - nodeId
         - attrId
        """
        self.send_get_attribute_local(shardId, nodeId, attrId)
        return self.recv_get_attribute_local()

    def send_get_attribute_local(self, shardId, nodeId, attrId):
        self._oprot.writeMessageBegin('get_attribute_local', TMessageType.CALL, self._seqid)
        args = get_attribute_local_args()
        args.shardId = shardId
        args.nodeId = nodeId
        args.attrId = attrId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_attribute_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_attribute_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_attribute_local failed: unknown result")

    def get_neighbors(self, nodeId):
        """
        Parameters:
         - nodeId
        """
        self.send_get_neighbors(nodeId)
        return self.recv_get_neighbors()

    def send_get_neighbors(self, nodeId):
        self._oprot.writeMessageBegin('get_neighbors', TMessageType.CALL, self._seqid)
        args = get_neighbors_args()
        args.nodeId = nodeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_neighbors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_neighbors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_neighbors failed: unknown result")

    def get_neighbors_local(self, shardId, nodeId):
        """
        Parameters:
         - shardId
         - nodeId
        """
        self.send_get_neighbors_local(shardId, nodeId)
        return self.recv_get_neighbors_local()

    def send_get_neighbors_local(self, shardId, nodeId):
        self._oprot.writeMessageBegin('get_neighbors_local', TMessageType.CALL, self._seqid)
        args = get_neighbors_local_args()
        args.shardId = shardId
        args.nodeId = nodeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_neighbors_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_neighbors_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_neighbors_local failed: unknown result")

    def get_neighbors_atype(self, nodeId, atype):
        """
        Parameters:
         - nodeId
         - atype
        """
        self.send_get_neighbors_atype(nodeId, atype)
        return self.recv_get_neighbors_atype()

    def send_get_neighbors_atype(self, nodeId, atype):
        self._oprot.writeMessageBegin('get_neighbors_atype', TMessageType.CALL, self._seqid)
        args = get_neighbors_atype_args()
        args.nodeId = nodeId
        args.atype = atype
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_neighbors_atype(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_neighbors_atype_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_neighbors_atype failed: unknown result")

    def get_neighbors_atype_local(self, shardId, nodeId, atype):
        """
        Parameters:
         - shardId
         - nodeId
         - atype
        """
        self.send_get_neighbors_atype_local(shardId, nodeId, atype)
        return self.recv_get_neighbors_atype_local()

    def send_get_neighbors_atype_local(self, shardId, nodeId, atype):
        self._oprot.writeMessageBegin('get_neighbors_atype_local', TMessageType.CALL, self._seqid)
        args = get_neighbors_atype_local_args()
        args.shardId = shardId
        args.nodeId = nodeId
        args.atype = atype
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_neighbors_atype_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_neighbors_atype_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_neighbors_atype_local failed: unknown result")

    def get_neighbors_attr(self, nodeId, attrId, attrKey):
        """
        Parameters:
         - nodeId
         - attrId
         - attrKey
        """
        self.send_get_neighbors_attr(nodeId, attrId, attrKey)
        return self.recv_get_neighbors_attr()

    def send_get_neighbors_attr(self, nodeId, attrId, attrKey):
        self._oprot.writeMessageBegin('get_neighbors_attr', TMessageType.CALL, self._seqid)
        args = get_neighbors_attr_args()
        args.nodeId = nodeId
        args.attrId = attrId
        args.attrKey = attrKey
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_neighbors_attr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_neighbors_attr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_neighbors_attr failed: unknown result")

    def get_neighbors_attr_local(self, shardId, nodeId, attrId, attrKey):
        """
        Parameters:
         - shardId
         - nodeId
         - attrId
         - attrKey
        """
        self.send_get_neighbors_attr_local(shardId, nodeId, attrId, attrKey)
        return self.recv_get_neighbors_attr_local()

    def send_get_neighbors_attr_local(self, shardId, nodeId, attrId, attrKey):
        self._oprot.writeMessageBegin('get_neighbors_attr_local', TMessageType.CALL, self._seqid)
        args = get_neighbors_attr_local_args()
        args.shardId = shardId
        args.nodeId = nodeId
        args.attrId = attrId
        args.attrKey = attrKey
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_neighbors_attr_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_neighbors_attr_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_neighbors_attr_local failed: unknown result")

    def get_nodes(self, attrId, attrKey):
        """
        Parameters:
         - attrId
         - attrKey
        """
        self.send_get_nodes(attrId, attrKey)
        return self.recv_get_nodes()

    def send_get_nodes(self, attrId, attrKey):
        self._oprot.writeMessageBegin('get_nodes', TMessageType.CALL, self._seqid)
        args = get_nodes_args()
        args.attrId = attrId
        args.attrKey = attrKey
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_nodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_nodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_nodes failed: unknown result")

    def get_nodes_local(self, attrId, attrKey):
        """
        Parameters:
         - attrId
         - attrKey
        """
        self.send_get_nodes_local(attrId, attrKey)
        return self.recv_get_nodes_local()

    def send_get_nodes_local(self, attrId, attrKey):
        self._oprot.writeMessageBegin('get_nodes_local', TMessageType.CALL, self._seqid)
        args = get_nodes_local_args()
        args.attrId = attrId
        args.attrKey = attrKey
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_nodes_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_nodes_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_nodes_local failed: unknown result")

    def get_nodes2(self, attrId1, attrKey1, attrId2, attrKey2):
        """
        Parameters:
         - attrId1
         - attrKey1
         - attrId2
         - attrKey2
        """
        self.send_get_nodes2(attrId1, attrKey1, attrId2, attrKey2)
        return self.recv_get_nodes2()

    def send_get_nodes2(self, attrId1, attrKey1, attrId2, attrKey2):
        self._oprot.writeMessageBegin('get_nodes2', TMessageType.CALL, self._seqid)
        args = get_nodes2_args()
        args.attrId1 = attrId1
        args.attrKey1 = attrKey1
        args.attrId2 = attrId2
        args.attrKey2 = attrKey2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_nodes2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_nodes2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_nodes2 failed: unknown result")

    def get_nodes2_local(self, attrId1, attrKey1, attrId2, attrKey2):
        """
        Parameters:
         - attrId1
         - attrKey1
         - attrId2
         - attrKey2
        """
        self.send_get_nodes2_local(attrId1, attrKey1, attrId2, attrKey2)
        return self.recv_get_nodes2_local()

    def send_get_nodes2_local(self, attrId1, attrKey1, attrId2, attrKey2):
        self._oprot.writeMessageBegin('get_nodes2_local', TMessageType.CALL, self._seqid)
        args = get_nodes2_local_args()
        args.attrId1 = attrId1
        args.attrKey1 = attrKey1
        args.attrId2 = attrId2
        args.attrKey2 = attrKey2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_nodes2_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_nodes2_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_nodes2_local failed: unknown result")

    def filter_nodes_local(self, nodeIds, attrId, attrKey):
        """
        Parameters:
         - nodeIds
         - attrId
         - attrKey
        """
        self.send_filter_nodes_local(nodeIds, attrId, attrKey)
        return self.recv_filter_nodes_local()

    def send_filter_nodes_local(self, nodeIds, attrId, attrKey):
        self._oprot.writeMessageBegin('filter_nodes_local', TMessageType.CALL, self._seqid)
        args = filter_nodes_local_args()
        args.nodeIds = nodeIds
        args.attrId = attrId
        args.attrKey = attrKey
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_filter_nodes_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = filter_nodes_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "filter_nodes_local failed: unknown result")

    def get_edge_attrs(self, nodeId, atype):
        """
        Parameters:
         - nodeId
         - atype
        """
        self.send_get_edge_attrs(nodeId, atype)
        return self.recv_get_edge_attrs()

    def send_get_edge_attrs(self, nodeId, atype):
        self._oprot.writeMessageBegin('get_edge_attrs', TMessageType.CALL, self._seqid)
        args = get_edge_attrs_args()
        args.nodeId = nodeId
        args.atype = atype
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_edge_attrs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_edge_attrs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_edge_attrs failed: unknown result")

    def get_edge_attrs_local(self, shardId, nodeId, atype):
        """
        Parameters:
         - shardId
         - nodeId
         - atype
        """
        self.send_get_edge_attrs_local(shardId, nodeId, atype)
        return self.recv_get_edge_attrs_local()

    def send_get_edge_attrs_local(self, shardId, nodeId, atype):
        self._oprot.writeMessageBegin('get_edge_attrs_local', TMessageType.CALL, self._seqid)
        args = get_edge_attrs_local_args()
        args.shardId = shardId
        args.nodeId = nodeId
        args.atype = atype
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_edge_attrs_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_edge_attrs_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_edge_attrs_local failed: unknown result")

    def assoc_range(self, src, atype, off, len):
        """
        Parameters:
         - src
         - atype
         - off
         - len
        """
        self.send_assoc_range(src, atype, off, len)
        return self.recv_assoc_range()

    def send_assoc_range(self, src, atype, off, len):
        self._oprot.writeMessageBegin('assoc_range', TMessageType.CALL, self._seqid)
        args = assoc_range_args()
        args.src = src
        args.atype = atype
        args.off = off
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_range(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_range_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_range failed: unknown result")

    def assoc_range_local(self, shardId, src, atype, off, len):
        """
        Parameters:
         - shardId
         - src
         - atype
         - off
         - len
        """
        self.send_assoc_range_local(shardId, src, atype, off, len)
        return self.recv_assoc_range_local()

    def send_assoc_range_local(self, shardId, src, atype, off, len):
        self._oprot.writeMessageBegin('assoc_range_local', TMessageType.CALL, self._seqid)
        args = assoc_range_local_args()
        args.shardId = shardId
        args.src = src
        args.atype = atype
        args.off = off
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_range_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_range_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_range_local failed: unknown result")

    def assoc_count(self, src, atype):
        """
        Parameters:
         - src
         - atype
        """
        self.send_assoc_count(src, atype)
        return self.recv_assoc_count()

    def send_assoc_count(self, src, atype):
        self._oprot.writeMessageBegin('assoc_count', TMessageType.CALL, self._seqid)
        args = assoc_count_args()
        args.src = src
        args.atype = atype
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_count failed: unknown result")

    def assoc_count_local(self, shardId, src, atype):
        """
        Parameters:
         - shardId
         - src
         - atype
        """
        self.send_assoc_count_local(shardId, src, atype)
        return self.recv_assoc_count_local()

    def send_assoc_count_local(self, shardId, src, atype):
        self._oprot.writeMessageBegin('assoc_count_local', TMessageType.CALL, self._seqid)
        args = assoc_count_local_args()
        args.shardId = shardId
        args.src = src
        args.atype = atype
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_count_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_count_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_count_local failed: unknown result")

    def assoc_get(self, src, atype, dstIdSet, tLow, tHigh):
        """
        Parameters:
         - src
         - atype
         - dstIdSet
         - tLow
         - tHigh
        """
        self.send_assoc_get(src, atype, dstIdSet, tLow, tHigh)
        return self.recv_assoc_get()

    def send_assoc_get(self, src, atype, dstIdSet, tLow, tHigh):
        self._oprot.writeMessageBegin('assoc_get', TMessageType.CALL, self._seqid)
        args = assoc_get_args()
        args.src = src
        args.atype = atype
        args.dstIdSet = dstIdSet
        args.tLow = tLow
        args.tHigh = tHigh
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_get failed: unknown result")

    def assoc_get_local(self, shardId, src, atype, dstIdSet, tLow, tHigh):
        """
        Parameters:
         - shardId
         - src
         - atype
         - dstIdSet
         - tLow
         - tHigh
        """
        self.send_assoc_get_local(shardId, src, atype, dstIdSet, tLow, tHigh)
        return self.recv_assoc_get_local()

    def send_assoc_get_local(self, shardId, src, atype, dstIdSet, tLow, tHigh):
        self._oprot.writeMessageBegin('assoc_get_local', TMessageType.CALL, self._seqid)
        args = assoc_get_local_args()
        args.shardId = shardId
        args.src = src
        args.atype = atype
        args.dstIdSet = dstIdSet
        args.tLow = tLow
        args.tHigh = tHigh
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_get_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_get_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_get_local failed: unknown result")

    def obj_add(self, attrs):
        """
        Parameters:
         - attrs
        """
        self.send_obj_add(attrs)
        return self.recv_obj_add()

    def send_obj_add(self, attrs):
        self._oprot.writeMessageBegin('obj_add', TMessageType.CALL, self._seqid)
        args = obj_add_args()
        args.attrs = attrs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_obj_add(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = obj_add_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "obj_add failed: unknown result")

    def obj_get(self, nodeId):
        """
        Parameters:
         - nodeId
        """
        self.send_obj_get(nodeId)
        return self.recv_obj_get()

    def send_obj_get(self, nodeId):
        self._oprot.writeMessageBegin('obj_get', TMessageType.CALL, self._seqid)
        args = obj_get_args()
        args.nodeId = nodeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_obj_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = obj_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "obj_get failed: unknown result")

    def obj_get_local(self, shardId, nodeId):
        """
        Parameters:
         - shardId
         - nodeId
        """
        self.send_obj_get_local(shardId, nodeId)
        return self.recv_obj_get_local()

    def send_obj_get_local(self, shardId, nodeId):
        self._oprot.writeMessageBegin('obj_get_local', TMessageType.CALL, self._seqid)
        args = obj_get_local_args()
        args.shardId = shardId
        args.nodeId = nodeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_obj_get_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = obj_get_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "obj_get_local failed: unknown result")

    def assoc_time_range(self, src, atype, tLow, tHigh, limit):
        """
        Parameters:
         - src
         - atype
         - tLow
         - tHigh
         - limit
        """
        self.send_assoc_time_range(src, atype, tLow, tHigh, limit)
        return self.recv_assoc_time_range()

    def send_assoc_time_range(self, src, atype, tLow, tHigh, limit):
        self._oprot.writeMessageBegin('assoc_time_range', TMessageType.CALL, self._seqid)
        args = assoc_time_range_args()
        args.src = src
        args.atype = atype
        args.tLow = tLow
        args.tHigh = tHigh
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_time_range(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_time_range_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_time_range failed: unknown result")

    def assoc_time_range_local(self, shardId, src, atype, tLow, tHigh, limit):
        """
        Parameters:
         - shardId
         - src
         - atype
         - tLow
         - tHigh
         - limit
        """
        self.send_assoc_time_range_local(shardId, src, atype, tLow, tHigh, limit)
        return self.recv_assoc_time_range_local()

    def send_assoc_time_range_local(self, shardId, src, atype, tLow, tHigh, limit):
        self._oprot.writeMessageBegin('assoc_time_range_local', TMessageType.CALL, self._seqid)
        args = assoc_time_range_local_args()
        args.shardId = shardId
        args.src = src
        args.atype = atype
        args.tLow = tLow
        args.tHigh = tHigh
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_time_range_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_time_range_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_time_range_local failed: unknown result")

    def assoc_add(self, src, atype, dst, time, attr):
        """
        Parameters:
         - src
         - atype
         - dst
         - time
         - attr
        """
        self.send_assoc_add(src, atype, dst, time, attr)
        return self.recv_assoc_add()

    def send_assoc_add(self, src, atype, dst, time, attr):
        self._oprot.writeMessageBegin('assoc_add', TMessageType.CALL, self._seqid)
        args = assoc_add_args()
        args.src = src
        args.atype = atype
        args.dst = dst
        args.time = time
        args.attr = attr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assoc_add(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assoc_add_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_add failed: unknown result")

    def getNode(self, id):
        """
        Parameters:
         - id
        """
        self.send_getNode(id)
        return self.recv_getNode()

    def send_getNode(self, id):
        self._oprot.writeMessageBegin('getNode', TMessageType.CALL, self._seqid)
        args = getNode_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNode failed: unknown result")

    def getNodeLocal(self, shard_id, id):
        """
        Parameters:
         - shard_id
         - id
        """
        self.send_getNodeLocal(shard_id, id)
        return self.recv_getNodeLocal()

    def send_getNodeLocal(self, shard_id, id):
        self._oprot.writeMessageBegin('getNodeLocal', TMessageType.CALL, self._seqid)
        args = getNodeLocal_args()
        args.shard_id = shard_id
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNodeLocal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNodeLocal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNodeLocal failed: unknown result")

    def addNode(self, id, data):
        """
        Parameters:
         - id
         - data
        """
        self.send_addNode(id, data)
        return self.recv_addNode()

    def send_addNode(self, id, data):
        self._oprot.writeMessageBegin('addNode', TMessageType.CALL, self._seqid)
        args = addNode_args()
        args.id = id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addNode failed: unknown result")

    def deleteNode(self, id):
        """
        Parameters:
         - id
        """
        self.send_deleteNode(id)
        return self.recv_deleteNode()

    def send_deleteNode(self, id):
        self._oprot.writeMessageBegin('deleteNode', TMessageType.CALL, self._seqid)
        args = deleteNode_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNode failed: unknown result")

    def deleteNodeLocal(self, shard_id, id):
        """
        Parameters:
         - shard_id
         - id
        """
        self.send_deleteNodeLocal(shard_id, id)
        return self.recv_deleteNodeLocal()

    def send_deleteNodeLocal(self, shard_id, id):
        self._oprot.writeMessageBegin('deleteNodeLocal', TMessageType.CALL, self._seqid)
        args = deleteNodeLocal_args()
        args.shard_id = shard_id
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteNodeLocal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteNodeLocal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNodeLocal failed: unknown result")

    def updateNode(self, id, data):
        """
        Parameters:
         - id
         - data
        """
        self.send_updateNode(id, data)
        return self.recv_updateNode()

    def send_updateNode(self, id, data):
        self._oprot.writeMessageBegin('updateNode', TMessageType.CALL, self._seqid)
        args = updateNode_args()
        args.id = id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNode failed: unknown result")

    def getLink(self, id1, link_type, id2):
        """
        Parameters:
         - id1
         - link_type
         - id2
        """
        self.send_getLink(id1, link_type, id2)
        return self.recv_getLink()

    def send_getLink(self, id1, link_type, id2):
        self._oprot.writeMessageBegin('getLink', TMessageType.CALL, self._seqid)
        args = getLink_args()
        args.id1 = id1
        args.link_type = link_type
        args.id2 = id2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLink(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLink_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLink failed: unknown result")

    def getLinkLocal(self, shard_id, id1, link_type, id2):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
         - id2
        """
        self.send_getLinkLocal(shard_id, id1, link_type, id2)
        return self.recv_getLinkLocal()

    def send_getLinkLocal(self, shard_id, id1, link_type, id2):
        self._oprot.writeMessageBegin('getLinkLocal', TMessageType.CALL, self._seqid)
        args = getLinkLocal_args()
        args.shard_id = shard_id
        args.id1 = id1
        args.link_type = link_type
        args.id2 = id2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLinkLocal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLinkLocal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkLocal failed: unknown result")

    def addLink(self, link):
        """
        Parameters:
         - link
        """
        self.send_addLink(link)
        return self.recv_addLink()

    def send_addLink(self, link):
        self._oprot.writeMessageBegin('addLink', TMessageType.CALL, self._seqid)
        args = addLink_args()
        args.link = link
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addLink(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addLink_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addLink failed: unknown result")

    def deleteLink(self, id1, link_type, id2):
        """
        Parameters:
         - id1
         - link_type
         - id2
        """
        self.send_deleteLink(id1, link_type, id2)
        return self.recv_deleteLink()

    def send_deleteLink(self, id1, link_type, id2):
        self._oprot.writeMessageBegin('deleteLink', TMessageType.CALL, self._seqid)
        args = deleteLink_args()
        args.id1 = id1
        args.link_type = link_type
        args.id2 = id2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteLink(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteLink_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteLink failed: unknown result")

    def deleteLinkLocal(self, shard_id, id1, link_type, id2):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
         - id2
        """
        self.send_deleteLinkLocal(shard_id, id1, link_type, id2)
        return self.recv_deleteLinkLocal()

    def send_deleteLinkLocal(self, shard_id, id1, link_type, id2):
        self._oprot.writeMessageBegin('deleteLinkLocal', TMessageType.CALL, self._seqid)
        args = deleteLinkLocal_args()
        args.shard_id = shard_id
        args.id1 = id1
        args.link_type = link_type
        args.id2 = id2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteLinkLocal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteLinkLocal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteLinkLocal failed: unknown result")

    def updateLink(self, link):
        """
        Parameters:
         - link
        """
        self.send_updateLink(link)
        return self.recv_updateLink()

    def send_updateLink(self, link):
        self._oprot.writeMessageBegin('updateLink', TMessageType.CALL, self._seqid)
        args = updateLink_args()
        args.link = link
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateLink(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateLink_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateLink failed: unknown result")

    def getLinkList(self, id1, link_type):
        """
        Parameters:
         - id1
         - link_type
        """
        self.send_getLinkList(id1, link_type)
        return self.recv_getLinkList()

    def send_getLinkList(self, id1, link_type):
        self._oprot.writeMessageBegin('getLinkList', TMessageType.CALL, self._seqid)
        args = getLinkList_args()
        args.id1 = id1
        args.link_type = link_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLinkList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLinkList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkList failed: unknown result")

    def getLinkListLocal(self, shard_id, id1, link_type):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
        """
        self.send_getLinkListLocal(shard_id, id1, link_type)
        return self.recv_getLinkListLocal()

    def send_getLinkListLocal(self, shard_id, id1, link_type):
        self._oprot.writeMessageBegin('getLinkListLocal', TMessageType.CALL, self._seqid)
        args = getLinkListLocal_args()
        args.shard_id = shard_id
        args.id1 = id1
        args.link_type = link_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLinkListLocal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLinkListLocal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkListLocal failed: unknown result")

    def getFilteredLinkList(self, id1, link_type, min_timestamp, max_timestamp, offset, limit):
        """
        Parameters:
         - id1
         - link_type
         - min_timestamp
         - max_timestamp
         - offset
         - limit
        """
        self.send_getFilteredLinkList(id1, link_type, min_timestamp, max_timestamp, offset, limit)
        return self.recv_getFilteredLinkList()

    def send_getFilteredLinkList(self, id1, link_type, min_timestamp, max_timestamp, offset, limit):
        self._oprot.writeMessageBegin('getFilteredLinkList', TMessageType.CALL, self._seqid)
        args = getFilteredLinkList_args()
        args.id1 = id1
        args.link_type = link_type
        args.min_timestamp = min_timestamp
        args.max_timestamp = max_timestamp
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFilteredLinkList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFilteredLinkList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFilteredLinkList failed: unknown result")

    def getFilteredLinkListLocal(self, shard_id, id1, link_type, min_timestamp, max_timestamp, offset, limit):
        """
        Parameters:
         - shard_id
         - id1
         - link_type
         - min_timestamp
         - max_timestamp
         - offset
         - limit
        """
        self.send_getFilteredLinkListLocal(shard_id, id1, link_type, min_timestamp, max_timestamp, offset, limit)
        return self.recv_getFilteredLinkListLocal()

    def send_getFilteredLinkListLocal(self, shard_id, id1, link_type, min_timestamp, max_timestamp, offset, limit):
        self._oprot.writeMessageBegin('getFilteredLinkListLocal', TMessageType.CALL, self._seqid)
        args = getFilteredLinkListLocal_args()
        args.shard_id = shard_id
        args.id1 = id1
        args.link_type = link_type
        args.min_timestamp = min_timestamp
        args.max_timestamp = max_timestamp
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFilteredLinkListLocal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFilteredLinkListLocal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFilteredLinkListLocal failed: unknown result")

    def countLinks(self, id1, link_type):
        """
        Parameters:
         - id1
         - link_type
        """
        self.send_countLinks(id1, link_type)
        return self.recv_countLinks()

    def send_countLinks(self, id1, link_type):
        self._oprot.writeMessageBegin('countLinks', TMessageType.CALL, self._seqid)
        args = countLinks_args()
        args.id1 = id1
        args.link_type = link_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countLinks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countLinks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countLinks failed: unknown result")

    def rpq(self, query):
        """
        Parameters:
         - query
        """
        self.send_rpq(query)
        return self.recv_rpq()

    def send_rpq(self, query):
        self._oprot.writeMessageBegin('rpq', TMessageType.CALL, self._seqid)
        args = rpq_args()
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rpq(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rpq_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rpq failed: unknown result")

    def path_query(self, query):
        """
        Parameters:
         - query
        """
        self.send_path_query(query)
        return self.recv_path_query()

    def send_path_query(self, query):
        self._oprot.writeMessageBegin('path_query', TMessageType.CALL, self._seqid)
        args = path_query_args()
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_path_query(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = path_query_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "path_query failed: unknown result")

    def path_query_local(self, query):
        """
        Parameters:
         - query
        """
        self.send_path_query_local(query)
        return self.recv_path_query_local()

    def send_path_query_local(self, query):
        self._oprot.writeMessageBegin('path_query_local', TMessageType.CALL, self._seqid)
        args = path_query_local_args()
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_path_query_local(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = path_query_local_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "path_query_local failed: unknown result")

    def advance_path_query_ctx(self, query, ctx):
        """
        Parameters:
         - query
         - ctx
        """
        self.send_advance_path_query_ctx(query, ctx)
        return self.recv_advance_path_query_ctx()

    def send_advance_path_query_ctx(self, query, ctx):
        self._oprot.writeMessageBegin('advance_path_query_ctx', TMessageType.CALL, self._seqid)
        args = advance_path_query_ctx_args()
        args.query = query
        args.ctx = ctx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_advance_path_query_ctx(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = advance_path_query_ctx_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "advance_path_query_ctx failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["init"] = Processor.process_init
        self._processMap["connect_to_aggregators"] = Processor.process_connect_to_aggregators
        self._processMap["disconnect_from_aggregators"] = Processor.process_disconnect_from_aggregators
        self._processMap["shutdown"] = Processor.process_shutdown
        self._processMap["record_edge_updates"] = Processor.process_record_edge_updates
        self._processMap["record_node_append"] = Processor.process_record_node_append
        self._processMap["get_attribute"] = Processor.process_get_attribute
        self._processMap["get_attribute_local"] = Processor.process_get_attribute_local
        self._processMap["get_neighbors"] = Processor.process_get_neighbors
        self._processMap["get_neighbors_local"] = Processor.process_get_neighbors_local
        self._processMap["get_neighbors_atype"] = Processor.process_get_neighbors_atype
        self._processMap["get_neighbors_atype_local"] = Processor.process_get_neighbors_atype_local
        self._processMap["get_neighbors_attr"] = Processor.process_get_neighbors_attr
        self._processMap["get_neighbors_attr_local"] = Processor.process_get_neighbors_attr_local
        self._processMap["get_nodes"] = Processor.process_get_nodes
        self._processMap["get_nodes_local"] = Processor.process_get_nodes_local
        self._processMap["get_nodes2"] = Processor.process_get_nodes2
        self._processMap["get_nodes2_local"] = Processor.process_get_nodes2_local
        self._processMap["filter_nodes_local"] = Processor.process_filter_nodes_local
        self._processMap["get_edge_attrs"] = Processor.process_get_edge_attrs
        self._processMap["get_edge_attrs_local"] = Processor.process_get_edge_attrs_local
        self._processMap["assoc_range"] = Processor.process_assoc_range
        self._processMap["assoc_range_local"] = Processor.process_assoc_range_local
        self._processMap["assoc_count"] = Processor.process_assoc_count
        self._processMap["assoc_count_local"] = Processor.process_assoc_count_local
        self._processMap["assoc_get"] = Processor.process_assoc_get
        self._processMap["assoc_get_local"] = Processor.process_assoc_get_local
        self._processMap["obj_add"] = Processor.process_obj_add
        self._processMap["obj_get"] = Processor.process_obj_get
        self._processMap["obj_get_local"] = Processor.process_obj_get_local
        self._processMap["assoc_time_range"] = Processor.process_assoc_time_range
        self._processMap["assoc_time_range_local"] = Processor.process_assoc_time_range_local
        self._processMap["assoc_add"] = Processor.process_assoc_add
        self._processMap["getNode"] = Processor.process_getNode
        self._processMap["getNodeLocal"] = Processor.process_getNodeLocal
        self._processMap["addNode"] = Processor.process_addNode
        self._processMap["deleteNode"] = Processor.process_deleteNode
        self._processMap["deleteNodeLocal"] = Processor.process_deleteNodeLocal
        self._processMap["updateNode"] = Processor.process_updateNode
        self._processMap["getLink"] = Processor.process_getLink
        self._processMap["getLinkLocal"] = Processor.process_getLinkLocal
        self._processMap["addLink"] = Processor.process_addLink
        self._processMap["deleteLink"] = Processor.process_deleteLink
        self._processMap["deleteLinkLocal"] = Processor.process_deleteLinkLocal
        self._processMap["updateLink"] = Processor.process_updateLink
        self._processMap["getLinkList"] = Processor.process_getLinkList
        self._processMap["getLinkListLocal"] = Processor.process_getLinkListLocal
        self._processMap["getFilteredLinkList"] = Processor.process_getFilteredLinkList
        self._processMap["getFilteredLinkListLocal"] = Processor.process_getFilteredLinkListLocal
        self._processMap["countLinks"] = Processor.process_countLinks
        self._processMap["rpq"] = Processor.process_rpq
        self._processMap["path_query"] = Processor.process_path_query
        self._processMap["path_query_local"] = Processor.process_path_query_local
        self._processMap["advance_path_query_ctx"] = Processor.process_advance_path_query_ctx

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_init(self, seqid, iprot, oprot):
        args = init_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = init_result()
        try:
            result.success = self._handler.init()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("init", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connect_to_aggregators(self, seqid, iprot, oprot):
        args = connect_to_aggregators_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connect_to_aggregators_result()
        try:
            result.success = self._handler.connect_to_aggregators()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connect_to_aggregators", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disconnect_from_aggregators(self, seqid, iprot, oprot):
        args = disconnect_from_aggregators_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disconnect_from_aggregators_result()
        try:
            self._handler.disconnect_from_aggregators()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disconnect_from_aggregators", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shutdown(self, seqid, iprot, oprot):
        args = shutdown_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shutdown_result()
        try:
            self._handler.shutdown()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shutdown", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_record_edge_updates(self, seqid, iprot, oprot):
        args = record_edge_updates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = record_edge_updates_result()
        try:
            self._handler.record_edge_updates(args.next_shard, args.local_shard, args.updates)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("record_edge_updates", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_record_node_append(self, seqid, iprot, oprot):
        args = record_node_append_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = record_node_append_result()
        try:
            self._handler.record_node_append(args.next_shard, args.local_shard, args.obj)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("record_node_append", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_attribute(self, seqid, iprot, oprot):
        args = get_attribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_attribute_result()
        try:
            result.success = self._handler.get_attribute(args.nodeId, args.attrId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_attribute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_attribute_local(self, seqid, iprot, oprot):
        args = get_attribute_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_attribute_local_result()
        try:
            result.success = self._handler.get_attribute_local(args.shardId, args.nodeId, args.attrId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_attribute_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_neighbors(self, seqid, iprot, oprot):
        args = get_neighbors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_neighbors_result()
        try:
            result.success = self._handler.get_neighbors(args.nodeId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_neighbors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_neighbors_local(self, seqid, iprot, oprot):
        args = get_neighbors_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_neighbors_local_result()
        try:
            result.success = self._handler.get_neighbors_local(args.shardId, args.nodeId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_neighbors_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_neighbors_atype(self, seqid, iprot, oprot):
        args = get_neighbors_atype_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_neighbors_atype_result()
        try:
            result.success = self._handler.get_neighbors_atype(args.nodeId, args.atype)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_neighbors_atype", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_neighbors_atype_local(self, seqid, iprot, oprot):
        args = get_neighbors_atype_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_neighbors_atype_local_result()
        try:
            result.success = self._handler.get_neighbors_atype_local(args.shardId, args.nodeId, args.atype)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_neighbors_atype_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_neighbors_attr(self, seqid, iprot, oprot):
        args = get_neighbors_attr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_neighbors_attr_result()
        try:
            result.success = self._handler.get_neighbors_attr(args.nodeId, args.attrId, args.attrKey)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_neighbors_attr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_neighbors_attr_local(self, seqid, iprot, oprot):
        args = get_neighbors_attr_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_neighbors_attr_local_result()
        try:
            result.success = self._handler.get_neighbors_attr_local(args.shardId, args.nodeId, args.attrId, args.attrKey)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_neighbors_attr_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_nodes(self, seqid, iprot, oprot):
        args = get_nodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_nodes_result()
        try:
            result.success = self._handler.get_nodes(args.attrId, args.attrKey)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_nodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_nodes_local(self, seqid, iprot, oprot):
        args = get_nodes_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_nodes_local_result()
        try:
            result.success = self._handler.get_nodes_local(args.attrId, args.attrKey)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_nodes_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_nodes2(self, seqid, iprot, oprot):
        args = get_nodes2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_nodes2_result()
        try:
            result.success = self._handler.get_nodes2(args.attrId1, args.attrKey1, args.attrId2, args.attrKey2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_nodes2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_nodes2_local(self, seqid, iprot, oprot):
        args = get_nodes2_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_nodes2_local_result()
        try:
            result.success = self._handler.get_nodes2_local(args.attrId1, args.attrKey1, args.attrId2, args.attrKey2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_nodes2_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_filter_nodes_local(self, seqid, iprot, oprot):
        args = filter_nodes_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = filter_nodes_local_result()
        try:
            result.success = self._handler.filter_nodes_local(args.nodeIds, args.attrId, args.attrKey)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("filter_nodes_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_edge_attrs(self, seqid, iprot, oprot):
        args = get_edge_attrs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_edge_attrs_result()
        try:
            result.success = self._handler.get_edge_attrs(args.nodeId, args.atype)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_edge_attrs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_edge_attrs_local(self, seqid, iprot, oprot):
        args = get_edge_attrs_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_edge_attrs_local_result()
        try:
            result.success = self._handler.get_edge_attrs_local(args.shardId, args.nodeId, args.atype)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_edge_attrs_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_range(self, seqid, iprot, oprot):
        args = assoc_range_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_range_result()
        try:
            result.success = self._handler.assoc_range(args.src, args.atype, args.off, args.len)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_range", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_range_local(self, seqid, iprot, oprot):
        args = assoc_range_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_range_local_result()
        try:
            result.success = self._handler.assoc_range_local(args.shardId, args.src, args.atype, args.off, args.len)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_range_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_count(self, seqid, iprot, oprot):
        args = assoc_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_count_result()
        try:
            result.success = self._handler.assoc_count(args.src, args.atype)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_count_local(self, seqid, iprot, oprot):
        args = assoc_count_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_count_local_result()
        try:
            result.success = self._handler.assoc_count_local(args.shardId, args.src, args.atype)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_count_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_get(self, seqid, iprot, oprot):
        args = assoc_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_get_result()
        try:
            result.success = self._handler.assoc_get(args.src, args.atype, args.dstIdSet, args.tLow, args.tHigh)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_get_local(self, seqid, iprot, oprot):
        args = assoc_get_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_get_local_result()
        try:
            result.success = self._handler.assoc_get_local(args.shardId, args.src, args.atype, args.dstIdSet, args.tLow, args.tHigh)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_get_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_obj_add(self, seqid, iprot, oprot):
        args = obj_add_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = obj_add_result()
        try:
            result.success = self._handler.obj_add(args.attrs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("obj_add", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_obj_get(self, seqid, iprot, oprot):
        args = obj_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = obj_get_result()
        try:
            result.success = self._handler.obj_get(args.nodeId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("obj_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_obj_get_local(self, seqid, iprot, oprot):
        args = obj_get_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = obj_get_local_result()
        try:
            result.success = self._handler.obj_get_local(args.shardId, args.nodeId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("obj_get_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_time_range(self, seqid, iprot, oprot):
        args = assoc_time_range_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_time_range_result()
        try:
            result.success = self._handler.assoc_time_range(args.src, args.atype, args.tLow, args.tHigh, args.limit)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_time_range", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_time_range_local(self, seqid, iprot, oprot):
        args = assoc_time_range_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_time_range_local_result()
        try:
            result.success = self._handler.assoc_time_range_local(args.shardId, args.src, args.atype, args.tLow, args.tHigh, args.limit)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_time_range_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assoc_add(self, seqid, iprot, oprot):
        args = assoc_add_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assoc_add_result()
        try:
            result.success = self._handler.assoc_add(args.src, args.atype, args.dst, args.time, args.attr)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assoc_add", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNode(self, seqid, iprot, oprot):
        args = getNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNode_result()
        try:
            result.success = self._handler.getNode(args.id)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNodeLocal(self, seqid, iprot, oprot):
        args = getNodeLocal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNodeLocal_result()
        try:
            result.success = self._handler.getNodeLocal(args.shard_id, args.id)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNodeLocal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addNode(self, seqid, iprot, oprot):
        args = addNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addNode_result()
        try:
            result.success = self._handler.addNode(args.id, args.data)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteNode(self, seqid, iprot, oprot):
        args = deleteNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteNode_result()
        try:
            result.success = self._handler.deleteNode(args.id)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteNodeLocal(self, seqid, iprot, oprot):
        args = deleteNodeLocal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteNodeLocal_result()
        try:
            result.success = self._handler.deleteNodeLocal(args.shard_id, args.id)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteNodeLocal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateNode(self, seqid, iprot, oprot):
        args = updateNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateNode_result()
        try:
            result.success = self._handler.updateNode(args.id, args.data)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLink(self, seqid, iprot, oprot):
        args = getLink_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLink_result()
        try:
            result.success = self._handler.getLink(args.id1, args.link_type, args.id2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLink", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLinkLocal(self, seqid, iprot, oprot):
        args = getLinkLocal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLinkLocal_result()
        try:
            result.success = self._handler.getLinkLocal(args.shard_id, args.id1, args.link_type, args.id2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLinkLocal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addLink(self, seqid, iprot, oprot):
        args = addLink_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addLink_result()
        try:
            result.success = self._handler.addLink(args.link)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addLink", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteLink(self, seqid, iprot, oprot):
        args = deleteLink_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteLink_result()
        try:
            result.success = self._handler.deleteLink(args.id1, args.link_type, args.id2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteLink", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteLinkLocal(self, seqid, iprot, oprot):
        args = deleteLinkLocal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteLinkLocal_result()
        try:
            result.success = self._handler.deleteLinkLocal(args.shard_id, args.id1, args.link_type, args.id2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteLinkLocal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateLink(self, seqid, iprot, oprot):
        args = updateLink_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateLink_result()
        try:
            result.success = self._handler.updateLink(args.link)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateLink", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLinkList(self, seqid, iprot, oprot):
        args = getLinkList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLinkList_result()
        try:
            result.success = self._handler.getLinkList(args.id1, args.link_type)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLinkList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLinkListLocal(self, seqid, iprot, oprot):
        args = getLinkListLocal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLinkListLocal_result()
        try:
            result.success = self._handler.getLinkListLocal(args.shard_id, args.id1, args.link_type)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLinkListLocal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFilteredLinkList(self, seqid, iprot, oprot):
        args = getFilteredLinkList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFilteredLinkList_result()
        try:
            result.success = self._handler.getFilteredLinkList(args.id1, args.link_type, args.min_timestamp, args.max_timestamp, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFilteredLinkList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFilteredLinkListLocal(self, seqid, iprot, oprot):
        args = getFilteredLinkListLocal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFilteredLinkListLocal_result()
        try:
            result.success = self._handler.getFilteredLinkListLocal(args.shard_id, args.id1, args.link_type, args.min_timestamp, args.max_timestamp, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFilteredLinkListLocal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countLinks(self, seqid, iprot, oprot):
        args = countLinks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countLinks_result()
        try:
            result.success = self._handler.countLinks(args.id1, args.link_type)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countLinks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rpq(self, seqid, iprot, oprot):
        args = rpq_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rpq_result()
        try:
            result.success = self._handler.rpq(args.query)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rpq", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_path_query(self, seqid, iprot, oprot):
        args = path_query_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = path_query_result()
        try:
            result.success = self._handler.path_query(args.query)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("path_query", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_path_query_local(self, seqid, iprot, oprot):
        args = path_query_local_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = path_query_local_result()
        try:
            result.success = self._handler.path_query_local(args.query)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("path_query_local", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_advance_path_query_ctx(self, seqid, iprot, oprot):
        args = advance_path_query_ctx_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = advance_path_query_ctx_result()
        try:
            result.success = self._handler.advance_path_query_ctx(args.query, args.ctx)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("advance_path_query_ctx", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class init_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('init_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class init_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('init_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class connect_to_aggregators_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('connect_to_aggregators_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class connect_to_aggregators_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('connect_to_aggregators_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class disconnect_from_aggregators_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('disconnect_from_aggregators_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class disconnect_from_aggregators_result(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('disconnect_from_aggregators_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class shutdown_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('shutdown_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class shutdown_result(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('shutdown_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class record_edge_updates_args(object):
    """
    Attributes:
     - next_shard
     - local_shard
     - updates
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'next_shard', None, None, ),  # 1
        (2, TType.I32, 'local_shard', None, None, ),  # 2
        (3, TType.LIST, 'updates', (TType.STRUCT, (ThriftSrcAtype, ThriftSrcAtype.thrift_spec), False), None, ),  # 3
    )

    def __init__(self, next_shard=None, local_shard=None, updates=None,):
        self.next_shard = next_shard
        self.local_shard = local_shard
        self.updates = updates

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.next_shard = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.local_shard = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.updates = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = ThriftSrcAtype()
                        _elem26.read(iprot)
                        self.updates.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('record_edge_updates_args')
        if self.next_shard is not None:
            oprot.writeFieldBegin('next_shard', TType.I32, 1)
            oprot.writeI32(self.next_shard)
            oprot.writeFieldEnd()
        if self.local_shard is not None:
            oprot.writeFieldBegin('local_shard', TType.I32, 2)
            oprot.writeI32(self.local_shard)
            oprot.writeFieldEnd()
        if self.updates is not None:
            oprot.writeFieldBegin('updates', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.updates))
            for iter27 in self.updates:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class record_edge_updates_result(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('record_edge_updates_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class record_node_append_args(object):
    """
    Attributes:
     - next_shard
     - local_shard
     - obj
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'next_shard', None, None, ),  # 1
        (2, TType.I32, 'local_shard', None, None, ),  # 2
        (3, TType.I64, 'obj', None, None, ),  # 3
    )

    def __init__(self, next_shard=None, local_shard=None, obj=None,):
        self.next_shard = next_shard
        self.local_shard = local_shard
        self.obj = obj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.next_shard = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.local_shard = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.obj = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('record_node_append_args')
        if self.next_shard is not None:
            oprot.writeFieldBegin('next_shard', TType.I32, 1)
            oprot.writeI32(self.next_shard)
            oprot.writeFieldEnd()
        if self.local_shard is not None:
            oprot.writeFieldBegin('local_shard', TType.I32, 2)
            oprot.writeI32(self.local_shard)
            oprot.writeFieldEnd()
        if self.obj is not None:
            oprot.writeFieldBegin('obj', TType.I64, 3)
            oprot.writeI64(self.obj)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class record_node_append_result(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('record_node_append_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_attribute_args(object):
    """
    Attributes:
     - nodeId
     - attrId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'nodeId', None, None, ),  # 1
        (2, TType.I32, 'attrId', None, None, ),  # 2
    )

    def __init__(self, nodeId=None, attrId=None,):
        self.nodeId = nodeId
        self.attrId = attrId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.attrId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_attribute_args')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 1)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.attrId is not None:
            oprot.writeFieldBegin('attrId', TType.I32, 2)
            oprot.writeI32(self.attrId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_attribute_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_attribute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_attribute_local_args(object):
    """
    Attributes:
     - shardId
     - nodeId
     - attrId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'nodeId', None, None, ),  # 2
        (3, TType.I32, 'attrId', None, None, ),  # 3
    )

    def __init__(self, shardId=None, nodeId=None, attrId=None,):
        self.shardId = shardId
        self.nodeId = nodeId
        self.attrId = attrId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.shardId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.attrId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_attribute_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I64, 1)
            oprot.writeI64(self.shardId)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 2)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.attrId is not None:
            oprot.writeFieldBegin('attrId', TType.I32, 3)
            oprot.writeI32(self.attrId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_attribute_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_attribute_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_args(object):
    """
    Attributes:
     - nodeId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'nodeId', None, None, ),  # 1
    )

    def __init__(self, nodeId=None,):
        self.nodeId = nodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_args')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 1)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI64()
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter34 in self.success:
                oprot.writeI64(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_local_args(object):
    """
    Attributes:
     - shardId
     - nodeId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'nodeId', None, None, ),  # 2
    )

    def __init__(self, shardId=None, nodeId=None,):
        self.shardId = shardId
        self.nodeId = nodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 2)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI64()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter41 in self.success:
                oprot.writeI64(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_atype_args(object):
    """
    Attributes:
     - nodeId
     - atype
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'nodeId', None, None, ),  # 1
        (2, TType.I64, 'atype', None, None, ),  # 2
    )

    def __init__(self, nodeId=None, atype=None,):
        self.nodeId = nodeId
        self.atype = atype

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_atype_args')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 1)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 2)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_atype_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI64()
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_atype_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter48 in self.success:
                oprot.writeI64(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_atype_local_args(object):
    """
    Attributes:
     - shardId
     - nodeId
     - atype
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'nodeId', None, None, ),  # 2
        (3, TType.I64, 'atype', None, None, ),  # 3
    )

    def __init__(self, shardId=None, nodeId=None, atype=None,):
        self.shardId = shardId
        self.nodeId = nodeId
        self.atype = atype

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_atype_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 2)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 3)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_atype_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readI64()
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_atype_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter55 in self.success:
                oprot.writeI64(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_attr_args(object):
    """
    Attributes:
     - nodeId
     - attrId
     - attrKey
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'nodeId', None, None, ),  # 1
        (2, TType.I32, 'attrId', None, None, ),  # 2
        (3, TType.STRING, 'attrKey', 'UTF8', None, ),  # 3
    )

    def __init__(self, nodeId=None, attrId=None, attrKey=None,):
        self.nodeId = nodeId
        self.attrId = attrId
        self.attrKey = attrKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.attrId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attrKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_attr_args')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 1)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.attrId is not None:
            oprot.writeFieldBegin('attrId', TType.I32, 2)
            oprot.writeI32(self.attrId)
            oprot.writeFieldEnd()
        if self.attrKey is not None:
            oprot.writeFieldBegin('attrKey', TType.STRING, 3)
            oprot.writeString(self.attrKey.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_attr_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readI64()
                        self.success.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_attr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter62 in self.success:
                oprot.writeI64(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_attr_local_args(object):
    """
    Attributes:
     - shardId
     - nodeId
     - attrId
     - attrKey
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'nodeId', None, None, ),  # 2
        (3, TType.I32, 'attrId', None, None, ),  # 3
        (4, TType.STRING, 'attrKey', 'UTF8', None, ),  # 4
    )

    def __init__(self, shardId=None, nodeId=None, attrId=None, attrKey=None,):
        self.shardId = shardId
        self.nodeId = nodeId
        self.attrId = attrId
        self.attrKey = attrKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.attrId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.attrKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_attr_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 2)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.attrId is not None:
            oprot.writeFieldBegin('attrId', TType.I32, 3)
            oprot.writeI32(self.attrId)
            oprot.writeFieldEnd()
        if self.attrKey is not None:
            oprot.writeFieldBegin('attrKey', TType.STRING, 4)
            oprot.writeString(self.attrKey.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_neighbors_attr_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readI64()
                        self.success.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_neighbors_attr_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter69 in self.success:
                oprot.writeI64(iter69)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes_args(object):
    """
    Attributes:
     - attrId
     - attrKey
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'attrId', None, None, ),  # 1
        (2, TType.STRING, 'attrKey', 'UTF8', None, ),  # 2
    )

    def __init__(self, attrId=None, attrKey=None,):
        self.attrId = attrId
        self.attrKey = attrKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.attrId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.attrKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes_args')
        if self.attrId is not None:
            oprot.writeFieldBegin('attrId', TType.I32, 1)
            oprot.writeI32(self.attrId)
            oprot.writeFieldEnd()
        if self.attrKey is not None:
            oprot.writeFieldBegin('attrKey', TType.STRING, 2)
            oprot.writeString(self.attrKey.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype73, _size70) = iprot.readSetBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readI64()
                        self.success.add(_elem75)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter76 in self.success:
                oprot.writeI64(iter76)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes_local_args(object):
    """
    Attributes:
     - attrId
     - attrKey
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'attrId', None, None, ),  # 1
        (2, TType.STRING, 'attrKey', 'UTF8', None, ),  # 2
    )

    def __init__(self, attrId=None, attrKey=None,):
        self.attrId = attrId
        self.attrKey = attrKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.attrId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.attrKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes_local_args')
        if self.attrId is not None:
            oprot.writeFieldBegin('attrId', TType.I32, 1)
            oprot.writeI32(self.attrId)
            oprot.writeFieldEnd()
        if self.attrKey is not None:
            oprot.writeFieldBegin('attrKey', TType.STRING, 2)
            oprot.writeString(self.attrKey.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype80, _size77) = iprot.readSetBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readI64()
                        self.success.add(_elem82)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter83 in self.success:
                oprot.writeI64(iter83)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes2_args(object):
    """
    Attributes:
     - attrId1
     - attrKey1
     - attrId2
     - attrKey2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'attrId1', None, None, ),  # 1
        (2, TType.STRING, 'attrKey1', 'UTF8', None, ),  # 2
        (3, TType.I32, 'attrId2', None, None, ),  # 3
        (4, TType.STRING, 'attrKey2', 'UTF8', None, ),  # 4
    )

    def __init__(self, attrId1=None, attrKey1=None, attrId2=None, attrKey2=None,):
        self.attrId1 = attrId1
        self.attrKey1 = attrKey1
        self.attrId2 = attrId2
        self.attrKey2 = attrKey2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.attrId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.attrKey1 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.attrId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.attrKey2 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes2_args')
        if self.attrId1 is not None:
            oprot.writeFieldBegin('attrId1', TType.I32, 1)
            oprot.writeI32(self.attrId1)
            oprot.writeFieldEnd()
        if self.attrKey1 is not None:
            oprot.writeFieldBegin('attrKey1', TType.STRING, 2)
            oprot.writeString(self.attrKey1.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey1)
            oprot.writeFieldEnd()
        if self.attrId2 is not None:
            oprot.writeFieldBegin('attrId2', TType.I32, 3)
            oprot.writeI32(self.attrId2)
            oprot.writeFieldEnd()
        if self.attrKey2 is not None:
            oprot.writeFieldBegin('attrKey2', TType.STRING, 4)
            oprot.writeString(self.attrKey2.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes2_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype87, _size84) = iprot.readSetBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readI64()
                        self.success.add(_elem89)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter90 in self.success:
                oprot.writeI64(iter90)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes2_local_args(object):
    """
    Attributes:
     - attrId1
     - attrKey1
     - attrId2
     - attrKey2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'attrId1', None, None, ),  # 1
        (2, TType.STRING, 'attrKey1', 'UTF8', None, ),  # 2
        (3, TType.I32, 'attrId2', None, None, ),  # 3
        (4, TType.STRING, 'attrKey2', 'UTF8', None, ),  # 4
    )

    def __init__(self, attrId1=None, attrKey1=None, attrId2=None, attrKey2=None,):
        self.attrId1 = attrId1
        self.attrKey1 = attrKey1
        self.attrId2 = attrId2
        self.attrKey2 = attrKey2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.attrId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.attrKey1 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.attrId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.attrKey2 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes2_local_args')
        if self.attrId1 is not None:
            oprot.writeFieldBegin('attrId1', TType.I32, 1)
            oprot.writeI32(self.attrId1)
            oprot.writeFieldEnd()
        if self.attrKey1 is not None:
            oprot.writeFieldBegin('attrKey1', TType.STRING, 2)
            oprot.writeString(self.attrKey1.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey1)
            oprot.writeFieldEnd()
        if self.attrId2 is not None:
            oprot.writeFieldBegin('attrId2', TType.I32, 3)
            oprot.writeI32(self.attrId2)
            oprot.writeFieldEnd()
        if self.attrKey2 is not None:
            oprot.writeFieldBegin('attrKey2', TType.STRING, 4)
            oprot.writeString(self.attrKey2.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_nodes2_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype94, _size91) = iprot.readSetBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readI64()
                        self.success.add(_elem96)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_nodes2_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter97 in self.success:
                oprot.writeI64(iter97)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class filter_nodes_local_args(object):
    """
    Attributes:
     - nodeIds
     - attrId
     - attrKey
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'nodeIds', (TType.I64, None, False), None, ),  # 1
        (2, TType.I32, 'attrId', None, None, ),  # 2
        (3, TType.STRING, 'attrKey', 'UTF8', None, ),  # 3
    )

    def __init__(self, nodeIds=None, attrId=None, attrKey=None,):
        self.nodeIds = nodeIds
        self.attrId = attrId
        self.attrKey = attrKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodeIds = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = iprot.readI64()
                        self.nodeIds.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.attrId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attrKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('filter_nodes_local_args')
        if self.nodeIds is not None:
            oprot.writeFieldBegin('nodeIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.nodeIds))
            for iter104 in self.nodeIds:
                oprot.writeI64(iter104)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attrId is not None:
            oprot.writeFieldBegin('attrId', TType.I32, 2)
            oprot.writeI32(self.attrId)
            oprot.writeFieldEnd()
        if self.attrKey is not None:
            oprot.writeFieldBegin('attrKey', TType.STRING, 3)
            oprot.writeString(self.attrKey.encode('utf-8') if sys.version_info[0] == 2 else self.attrKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class filter_nodes_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = iprot.readI64()
                        self.success.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('filter_nodes_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter111 in self.success:
                oprot.writeI64(iter111)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_edge_attrs_args(object):
    """
    Attributes:
     - nodeId
     - atype
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'nodeId', None, None, ),  # 1
        (2, TType.I64, 'atype', None, None, ),  # 2
    )

    def __init__(self, nodeId=None, atype=None,):
        self.nodeId = nodeId
        self.atype = atype

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_edge_attrs_args')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 1)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 2)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_edge_attrs_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_edge_attrs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter118 in self.success:
                oprot.writeString(iter118.encode('utf-8') if sys.version_info[0] == 2 else iter118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_edge_attrs_local_args(object):
    """
    Attributes:
     - shardId
     - nodeId
     - atype
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'nodeId', None, None, ),  # 2
        (3, TType.I64, 'atype', None, None, ),  # 3
    )

    def __init__(self, shardId=None, nodeId=None, atype=None,):
        self.shardId = shardId
        self.nodeId = nodeId
        self.atype = atype

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_edge_attrs_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 2)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 3)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_edge_attrs_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_edge_attrs_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter125 in self.success:
                oprot.writeString(iter125.encode('utf-8') if sys.version_info[0] == 2 else iter125)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_range_args(object):
    """
    Attributes:
     - src
     - atype
     - off
     - len
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'src', None, None, ),  # 1
        (2, TType.I64, 'atype', None, None, ),  # 2
        (3, TType.I32, 'off', None, None, ),  # 3
        (4, TType.I32, 'len', None, None, ),  # 4
    )

    def __init__(self, src=None, atype=None, off=None, len=None,):
        self.src = src
        self.atype = atype
        self.off = off
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.off = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_range_args')
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 1)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 2)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        if self.off is not None:
            oprot.writeFieldBegin('off', TType.I32, 3)
            oprot.writeI32(self.off)
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 4)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_range_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = ThriftAssoc()
                        _elem131.read(iprot)
                        self.success.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_range_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter132 in self.success:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_range_local_args(object):
    """
    Attributes:
     - shardId
     - src
     - atype
     - off
     - len
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'src', None, None, ),  # 2
        (3, TType.I64, 'atype', None, None, ),  # 3
        (4, TType.I32, 'off', None, None, ),  # 4
        (5, TType.I32, 'len', None, None, ),  # 5
    )

    def __init__(self, shardId=None, src=None, atype=None, off=None, len=None,):
        self.shardId = shardId
        self.src = src
        self.atype = atype
        self.off = off
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.off = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_range_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 2)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 3)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        if self.off is not None:
            oprot.writeFieldBegin('off', TType.I32, 4)
            oprot.writeI32(self.off)
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 5)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_range_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = ThriftAssoc()
                        _elem138.read(iprot)
                        self.success.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_range_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter139 in self.success:
                iter139.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_count_args(object):
    """
    Attributes:
     - src
     - atype
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'src', None, None, ),  # 1
        (2, TType.I64, 'atype', None, None, ),  # 2
    )

    def __init__(self, src=None, atype=None,):
        self.src = src
        self.atype = atype

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_count_args')
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 1)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 2)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_count_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_count_local_args(object):
    """
    Attributes:
     - shardId
     - src
     - atype
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'src', None, None, ),  # 2
        (3, TType.I64, 'atype', None, None, ),  # 3
    )

    def __init__(self, shardId=None, src=None, atype=None,):
        self.shardId = shardId
        self.src = src
        self.atype = atype

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_count_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 2)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 3)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_count_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_count_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_get_args(object):
    """
    Attributes:
     - src
     - atype
     - dstIdSet
     - tLow
     - tHigh
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'src', None, None, ),  # 1
        (2, TType.I64, 'atype', None, None, ),  # 2
        (3, TType.SET, 'dstIdSet', (TType.I64, None, False), None, ),  # 3
        (4, TType.I64, 'tLow', None, None, ),  # 4
        (5, TType.I64, 'tHigh', None, None, ),  # 5
    )

    def __init__(self, src=None, atype=None, dstIdSet=None, tLow=None, tHigh=None,):
        self.src = src
        self.atype = atype
        self.dstIdSet = dstIdSet
        self.tLow = tLow
        self.tHigh = tHigh

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.dstIdSet = set()
                    (_etype143, _size140) = iprot.readSetBegin()
                    for _i144 in range(_size140):
                        _elem145 = iprot.readI64()
                        self.dstIdSet.add(_elem145)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.tLow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.tHigh = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_get_args')
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 1)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 2)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        if self.dstIdSet is not None:
            oprot.writeFieldBegin('dstIdSet', TType.SET, 3)
            oprot.writeSetBegin(TType.I64, len(self.dstIdSet))
            for iter146 in self.dstIdSet:
                oprot.writeI64(iter146)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.tLow is not None:
            oprot.writeFieldBegin('tLow', TType.I64, 4)
            oprot.writeI64(self.tLow)
            oprot.writeFieldEnd()
        if self.tHigh is not None:
            oprot.writeFieldBegin('tHigh', TType.I64, 5)
            oprot.writeI64(self.tHigh)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_get_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = ThriftAssoc()
                        _elem152.read(iprot)
                        self.success.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter153 in self.success:
                iter153.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_get_local_args(object):
    """
    Attributes:
     - shardId
     - src
     - atype
     - dstIdSet
     - tLow
     - tHigh
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'src', None, None, ),  # 2
        (3, TType.I64, 'atype', None, None, ),  # 3
        (4, TType.SET, 'dstIdSet', (TType.I64, None, False), None, ),  # 4
        (5, TType.I64, 'tLow', None, None, ),  # 5
        (6, TType.I64, 'tHigh', None, None, ),  # 6
    )

    def __init__(self, shardId=None, src=None, atype=None, dstIdSet=None, tLow=None, tHigh=None,):
        self.shardId = shardId
        self.src = src
        self.atype = atype
        self.dstIdSet = dstIdSet
        self.tLow = tLow
        self.tHigh = tHigh

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.dstIdSet = set()
                    (_etype157, _size154) = iprot.readSetBegin()
                    for _i158 in range(_size154):
                        _elem159 = iprot.readI64()
                        self.dstIdSet.add(_elem159)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.tLow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.tHigh = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_get_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 2)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 3)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        if self.dstIdSet is not None:
            oprot.writeFieldBegin('dstIdSet', TType.SET, 4)
            oprot.writeSetBegin(TType.I64, len(self.dstIdSet))
            for iter160 in self.dstIdSet:
                oprot.writeI64(iter160)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.tLow is not None:
            oprot.writeFieldBegin('tLow', TType.I64, 5)
            oprot.writeI64(self.tLow)
            oprot.writeFieldEnd()
        if self.tHigh is not None:
            oprot.writeFieldBegin('tHigh', TType.I64, 6)
            oprot.writeI64(self.tHigh)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_get_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = ThriftAssoc()
                        _elem166.read(iprot)
                        self.success.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_get_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter167 in self.success:
                iter167.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class obj_add_args(object):
    """
    Attributes:
     - attrs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'attrs', (TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, attrs=None,):
        self.attrs = attrs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.attrs = []
                    (_etype171, _size168) = iprot.readListBegin()
                    for _i172 in range(_size168):
                        _elem173 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.attrs.append(_elem173)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('obj_add_args')
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.attrs))
            for iter174 in self.attrs:
                oprot.writeString(iter174.encode('utf-8') if sys.version_info[0] == 2 else iter174)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class obj_add_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('obj_add_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class obj_get_args(object):
    """
    Attributes:
     - nodeId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'nodeId', None, None, ),  # 1
    )

    def __init__(self, nodeId=None,):
        self.nodeId = nodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('obj_get_args')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 1)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class obj_get_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype178, _size175) = iprot.readListBegin()
                    for _i179 in range(_size175):
                        _elem180 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem180)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('obj_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter181 in self.success:
                oprot.writeString(iter181.encode('utf-8') if sys.version_info[0] == 2 else iter181)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class obj_get_local_args(object):
    """
    Attributes:
     - shardId
     - nodeId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'nodeId', None, None, ),  # 2
    )

    def __init__(self, shardId=None, nodeId=None,):
        self.shardId = shardId
        self.nodeId = nodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nodeId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('obj_get_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I64, 2)
            oprot.writeI64(self.nodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class obj_get_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype185, _size182) = iprot.readListBegin()
                    for _i186 in range(_size182):
                        _elem187 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('obj_get_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter188 in self.success:
                oprot.writeString(iter188.encode('utf-8') if sys.version_info[0] == 2 else iter188)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_time_range_args(object):
    """
    Attributes:
     - src
     - atype
     - tLow
     - tHigh
     - limit
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'src', None, None, ),  # 1
        (2, TType.I64, 'atype', None, None, ),  # 2
        (3, TType.I64, 'tLow', None, None, ),  # 3
        (4, TType.I64, 'tHigh', None, None, ),  # 4
        (5, TType.I32, 'limit', None, None, ),  # 5
    )

    def __init__(self, src=None, atype=None, tLow=None, tHigh=None, limit=None,):
        self.src = src
        self.atype = atype
        self.tLow = tLow
        self.tHigh = tHigh
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.tLow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.tHigh = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_time_range_args')
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 1)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 2)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        if self.tLow is not None:
            oprot.writeFieldBegin('tLow', TType.I64, 3)
            oprot.writeI64(self.tLow)
            oprot.writeFieldEnd()
        if self.tHigh is not None:
            oprot.writeFieldBegin('tHigh', TType.I64, 4)
            oprot.writeI64(self.tHigh)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 5)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_time_range_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype192, _size189) = iprot.readListBegin()
                    for _i193 in range(_size189):
                        _elem194 = ThriftAssoc()
                        _elem194.read(iprot)
                        self.success.append(_elem194)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_time_range_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter195 in self.success:
                iter195.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_time_range_local_args(object):
    """
    Attributes:
     - shardId
     - src
     - atype
     - tLow
     - tHigh
     - limit
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'shardId', None, None, ),  # 1
        (2, TType.I64, 'src', None, None, ),  # 2
        (3, TType.I64, 'atype', None, None, ),  # 3
        (4, TType.I64, 'tLow', None, None, ),  # 4
        (5, TType.I64, 'tHigh', None, None, ),  # 5
        (6, TType.I32, 'limit', None, None, ),  # 6
    )

    def __init__(self, shardId=None, src=None, atype=None, tLow=None, tHigh=None, limit=None,):
        self.shardId = shardId
        self.src = src
        self.atype = atype
        self.tLow = tLow
        self.tHigh = tHigh
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.shardId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.tLow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.tHigh = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_time_range_local_args')
        if self.shardId is not None:
            oprot.writeFieldBegin('shardId', TType.I32, 1)
            oprot.writeI32(self.shardId)
            oprot.writeFieldEnd()
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 2)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 3)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        if self.tLow is not None:
            oprot.writeFieldBegin('tLow', TType.I64, 4)
            oprot.writeI64(self.tLow)
            oprot.writeFieldEnd()
        if self.tHigh is not None:
            oprot.writeFieldBegin('tHigh', TType.I64, 5)
            oprot.writeI64(self.tHigh)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 6)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_time_range_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype199, _size196) = iprot.readListBegin()
                    for _i200 in range(_size196):
                        _elem201 = ThriftAssoc()
                        _elem201.read(iprot)
                        self.success.append(_elem201)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_time_range_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter202 in self.success:
                iter202.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_add_args(object):
    """
    Attributes:
     - src
     - atype
     - dst
     - time
     - attr
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'src', None, None, ),  # 1
        (2, TType.I64, 'atype', None, None, ),  # 2
        (3, TType.I64, 'dst', None, None, ),  # 3
        (4, TType.I64, 'time', None, None, ),  # 4
        (5, TType.STRING, 'attr', 'UTF8', None, ),  # 5
    )

    def __init__(self, src=None, atype=None, dst=None, time=None, attr=None,):
        self.src = src
        self.atype = atype
        self.dst = dst
        self.time = time
        self.attr = attr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.src = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.atype = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.dst = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.attr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_add_args')
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I64, 1)
            oprot.writeI64(self.src)
            oprot.writeFieldEnd()
        if self.atype is not None:
            oprot.writeFieldBegin('atype', TType.I64, 2)
            oprot.writeI64(self.atype)
            oprot.writeFieldEnd()
        if self.dst is not None:
            oprot.writeFieldBegin('dst', TType.I64, 3)
            oprot.writeI64(self.dst)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I64, 4)
            oprot.writeI64(self.time)
            oprot.writeFieldEnd()
        if self.attr is not None:
            oprot.writeFieldBegin('attr', TType.STRING, 5)
            oprot.writeString(self.attr.encode('utf-8') if sys.version_info[0] == 2 else self.attr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class assoc_add_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('assoc_add_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getNode_args(object):
    """
    Attributes:
     - id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id', None, None, ),  # 1
    )

    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getNode_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getNode_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getNodeLocal_args(object):
    """
    Attributes:
     - shard_id
     - id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'shard_id', None, None, ),  # 1
        (2, TType.I64, 'id', None, None, ),  # 2
    )

    def __init__(self, shard_id=None, id=None,):
        self.shard_id = shard_id
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.shard_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getNodeLocal_args')
        if self.shard_id is not None:
            oprot.writeFieldBegin('shard_id', TType.I64, 1)
            oprot.writeI64(self.shard_id)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 2)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getNodeLocal_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getNodeLocal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addNode_args(object):
    """
    Attributes:
     - id
     - data
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id', None, None, ),  # 1
        (2, TType.STRING, 'data', 'UTF8', None, ),  # 2
    )

    def __init__(self, id=None, data=None,):
        self.id = id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('addNode_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeString(self.data.encode('utf-8') if sys.version_info[0] == 2 else self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addNode_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('addNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteNode_args(object):
    """
    Attributes:
     - id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id', None, None, ),  # 1
    )

    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteNode_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteNode_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteNodeLocal_args(object):
    """
    Attributes:
     - shard_id
     - id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'shard_id', None, None, ),  # 1
        (2, TType.I64, 'id', None, None, ),  # 2
    )

    def __init__(self, shard_id=None, id=None,):
        self.shard_id = shard_id
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.shard_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteNodeLocal_args')
        if self.shard_id is not None:
            oprot.writeFieldBegin('shard_id', TType.I64, 1)
            oprot.writeI64(self.shard_id)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 2)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteNodeLocal_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteNodeLocal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateNode_args(object):
    """
    Attributes:
     - id
     - data
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id', None, None, ),  # 1
        (2, TType.STRING, 'data', 'UTF8', None, ),  # 2
    )

    def __init__(self, id=None, data=None,):
        self.id = id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateNode_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeString(self.data.encode('utf-8') if sys.version_info[0] == 2 else self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateNode_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLink_args(object):
    """
    Attributes:
     - id1
     - link_type
     - id2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id1', None, None, ),  # 1
        (2, TType.I64, 'link_type', None, None, ),  # 2
        (3, TType.I64, 'id2', None, None, ),  # 3
    )

    def __init__(self, id1=None, link_type=None, id2=None,):
        self.id1 = id1
        self.link_type = link_type
        self.id2 = id2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.id2 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLink_args')
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 1)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 2)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        if self.id2 is not None:
            oprot.writeFieldBegin('id2', TType.I64, 3)
            oprot.writeI64(self.id2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLink_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ThriftAssoc, ThriftAssoc.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ThriftAssoc()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLink_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLinkLocal_args(object):
    """
    Attributes:
     - shard_id
     - id1
     - link_type
     - id2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'shard_id', None, None, ),  # 1
        (2, TType.I64, 'id1', None, None, ),  # 2
        (3, TType.I64, 'link_type', None, None, ),  # 3
        (4, TType.I64, 'id2', None, None, ),  # 4
    )

    def __init__(self, shard_id=None, id1=None, link_type=None, id2=None,):
        self.shard_id = shard_id
        self.id1 = id1
        self.link_type = link_type
        self.id2 = id2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.shard_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.id2 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLinkLocal_args')
        if self.shard_id is not None:
            oprot.writeFieldBegin('shard_id', TType.I64, 1)
            oprot.writeI64(self.shard_id)
            oprot.writeFieldEnd()
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 2)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 3)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        if self.id2 is not None:
            oprot.writeFieldBegin('id2', TType.I64, 4)
            oprot.writeI64(self.id2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLinkLocal_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ThriftAssoc, ThriftAssoc.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ThriftAssoc()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLinkLocal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addLink_args(object):
    """
    Attributes:
     - link
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'link', (ThriftAssoc, ThriftAssoc.thrift_spec), None, ),  # 1
    )

    def __init__(self, link=None,):
        self.link = link

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.link = ThriftAssoc()
                    self.link.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('addLink_args')
        if self.link is not None:
            oprot.writeFieldBegin('link', TType.STRUCT, 1)
            self.link.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addLink_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('addLink_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteLink_args(object):
    """
    Attributes:
     - id1
     - link_type
     - id2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id1', None, None, ),  # 1
        (2, TType.I64, 'link_type', None, None, ),  # 2
        (3, TType.I64, 'id2', None, None, ),  # 3
    )

    def __init__(self, id1=None, link_type=None, id2=None,):
        self.id1 = id1
        self.link_type = link_type
        self.id2 = id2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.id2 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteLink_args')
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 1)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 2)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        if self.id2 is not None:
            oprot.writeFieldBegin('id2', TType.I64, 3)
            oprot.writeI64(self.id2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteLink_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteLink_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteLinkLocal_args(object):
    """
    Attributes:
     - shard_id
     - id1
     - link_type
     - id2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'shard_id', None, None, ),  # 1
        (2, TType.I64, 'id1', None, None, ),  # 2
        (3, TType.I64, 'link_type', None, None, ),  # 3
        (4, TType.I64, 'id2', None, None, ),  # 4
    )

    def __init__(self, shard_id=None, id1=None, link_type=None, id2=None,):
        self.shard_id = shard_id
        self.id1 = id1
        self.link_type = link_type
        self.id2 = id2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.shard_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.id2 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteLinkLocal_args')
        if self.shard_id is not None:
            oprot.writeFieldBegin('shard_id', TType.I64, 1)
            oprot.writeI64(self.shard_id)
            oprot.writeFieldEnd()
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 2)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 3)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        if self.id2 is not None:
            oprot.writeFieldBegin('id2', TType.I64, 4)
            oprot.writeI64(self.id2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class deleteLinkLocal_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('deleteLinkLocal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateLink_args(object):
    """
    Attributes:
     - link
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'link', (ThriftAssoc, ThriftAssoc.thrift_spec), None, ),  # 1
    )

    def __init__(self, link=None,):
        self.link = link

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.link = ThriftAssoc()
                    self.link.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateLink_args')
        if self.link is not None:
            oprot.writeFieldBegin('link', TType.STRUCT, 1)
            self.link.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateLink_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateLink_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLinkList_args(object):
    """
    Attributes:
     - id1
     - link_type
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id1', None, None, ),  # 1
        (2, TType.I64, 'link_type', None, None, ),  # 2
    )

    def __init__(self, id1=None, link_type=None,):
        self.id1 = id1
        self.link_type = link_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLinkList_args')
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 1)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 2)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLinkList_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype206, _size203) = iprot.readListBegin()
                    for _i207 in range(_size203):
                        _elem208 = ThriftAssoc()
                        _elem208.read(iprot)
                        self.success.append(_elem208)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLinkList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter209 in self.success:
                iter209.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLinkListLocal_args(object):
    """
    Attributes:
     - shard_id
     - id1
     - link_type
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'shard_id', None, None, ),  # 1
        (2, TType.I64, 'id1', None, None, ),  # 2
        (3, TType.I64, 'link_type', None, None, ),  # 3
    )

    def __init__(self, shard_id=None, id1=None, link_type=None,):
        self.shard_id = shard_id
        self.id1 = id1
        self.link_type = link_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.shard_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLinkListLocal_args')
        if self.shard_id is not None:
            oprot.writeFieldBegin('shard_id', TType.I64, 1)
            oprot.writeI64(self.shard_id)
            oprot.writeFieldEnd()
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 2)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 3)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getLinkListLocal_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype213, _size210) = iprot.readListBegin()
                    for _i214 in range(_size210):
                        _elem215 = ThriftAssoc()
                        _elem215.read(iprot)
                        self.success.append(_elem215)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getLinkListLocal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter216 in self.success:
                iter216.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilteredLinkList_args(object):
    """
    Attributes:
     - id1
     - link_type
     - min_timestamp
     - max_timestamp
     - offset
     - limit
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id1', None, None, ),  # 1
        (2, TType.I64, 'link_type', None, None, ),  # 2
        (3, TType.I64, 'min_timestamp', None, None, ),  # 3
        (4, TType.I64, 'max_timestamp', None, None, ),  # 4
        (5, TType.I64, 'offset', None, None, ),  # 5
        (6, TType.I64, 'limit', None, None, ),  # 6
    )

    def __init__(self, id1=None, link_type=None, min_timestamp=None, max_timestamp=None, offset=None, limit=None,):
        self.id1 = id1
        self.link_type = link_type
        self.min_timestamp = min_timestamp
        self.max_timestamp = max_timestamp
        self.offset = offset
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.min_timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.max_timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilteredLinkList_args')
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 1)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 2)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        if self.min_timestamp is not None:
            oprot.writeFieldBegin('min_timestamp', TType.I64, 3)
            oprot.writeI64(self.min_timestamp)
            oprot.writeFieldEnd()
        if self.max_timestamp is not None:
            oprot.writeFieldBegin('max_timestamp', TType.I64, 4)
            oprot.writeI64(self.max_timestamp)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 6)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilteredLinkList_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype220, _size217) = iprot.readListBegin()
                    for _i221 in range(_size217):
                        _elem222 = ThriftAssoc()
                        _elem222.read(iprot)
                        self.success.append(_elem222)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilteredLinkList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter223 in self.success:
                iter223.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilteredLinkListLocal_args(object):
    """
    Attributes:
     - shard_id
     - id1
     - link_type
     - min_timestamp
     - max_timestamp
     - offset
     - limit
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'shard_id', None, None, ),  # 1
        (2, TType.I64, 'id1', None, None, ),  # 2
        (3, TType.I64, 'link_type', None, None, ),  # 3
        (4, TType.I64, 'min_timestamp', None, None, ),  # 4
        (5, TType.I64, 'max_timestamp', None, None, ),  # 5
        (6, TType.I64, 'offset', None, None, ),  # 6
        (7, TType.I64, 'limit', None, None, ),  # 7
    )

    def __init__(self, shard_id=None, id1=None, link_type=None, min_timestamp=None, max_timestamp=None, offset=None, limit=None,):
        self.shard_id = shard_id
        self.id1 = id1
        self.link_type = link_type
        self.min_timestamp = min_timestamp
        self.max_timestamp = max_timestamp
        self.offset = offset
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.shard_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.min_timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.max_timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilteredLinkListLocal_args')
        if self.shard_id is not None:
            oprot.writeFieldBegin('shard_id', TType.I64, 1)
            oprot.writeI64(self.shard_id)
            oprot.writeFieldEnd()
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 2)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 3)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        if self.min_timestamp is not None:
            oprot.writeFieldBegin('min_timestamp', TType.I64, 4)
            oprot.writeI64(self.min_timestamp)
            oprot.writeFieldEnd()
        if self.max_timestamp is not None:
            oprot.writeFieldBegin('max_timestamp', TType.I64, 5)
            oprot.writeI64(self.max_timestamp)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 6)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 7)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilteredLinkListLocal_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ThriftAssoc, ThriftAssoc.thrift_spec), False), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype227, _size224) = iprot.readListBegin()
                    for _i228 in range(_size224):
                        _elem229 = ThriftAssoc()
                        _elem229.read(iprot)
                        self.success.append(_elem229)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilteredLinkListLocal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter230 in self.success:
                iter230.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class countLinks_args(object):
    """
    Attributes:
     - id1
     - link_type
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'id1', None, None, ),  # 1
        (2, TType.I64, 'link_type', None, None, ),  # 2
    )

    def __init__(self, id1=None, link_type=None,):
        self.id1 = id1
        self.link_type = link_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id1 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.link_type = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('countLinks_args')
        if self.id1 is not None:
            oprot.writeFieldBegin('id1', TType.I64, 1)
            oprot.writeI64(self.id1)
            oprot.writeFieldEnd()
        if self.link_type is not None:
            oprot.writeFieldBegin('link_type', TType.I64, 2)
            oprot.writeI64(self.link_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class countLinks_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('countLinks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rpq_args(object):
    """
    Attributes:
     - query
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'query', (RPQuery, RPQuery.thrift_spec), None, ),  # 1
    )

    def __init__(self, query=None,):
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.query = RPQuery()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rpq_args')
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 1)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rpq_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (RPQCtx, RPQCtx.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RPQCtx()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rpq_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class path_query_args(object):
    """
    Attributes:
     - query
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'query', (TType.I64, None, False), None, ),  # 1
    )

    def __init__(self, query=None,):
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.query = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = iprot.readI64()
                        self.query.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('path_query_args')
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.query))
            for iter237 in self.query:
                oprot.writeI64(iter237)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class path_query_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (RPQCtx, RPQCtx.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RPQCtx()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('path_query_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class path_query_local_args(object):
    """
    Attributes:
     - query
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'query', (TType.I64, None, False), None, ),  # 1
    )

    def __init__(self, query=None,):
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.query = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = iprot.readI64()
                        self.query.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('path_query_local_args')
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.query))
            for iter244 in self.query:
                oprot.writeI64(iter244)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class path_query_local_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (RPQCtx, RPQCtx.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RPQCtx()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('path_query_local_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class advance_path_query_ctx_args(object):
    """
    Attributes:
     - query
     - ctx
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'query', (TType.I64, None, False), None, ),  # 1
        (2, TType.STRUCT, 'ctx', (RPQCtx, RPQCtx.thrift_spec), None, ),  # 2
    )

    def __init__(self, query=None, ctx=None,):
        self.query = query
        self.ctx = ctx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.query = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = iprot.readI64()
                        self.query.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ctx = RPQCtx()
                    self.ctx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('advance_path_query_ctx_args')
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.query))
            for iter251 in self.query:
                oprot.writeI64(iter251)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ctx is not None:
            oprot.writeFieldBegin('ctx', TType.STRUCT, 2)
            self.ctx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class advance_path_query_ctx_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (RPQCtx, RPQCtx.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RPQCtx()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('advance_path_query_ctx_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
