/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "GraphQueryAggregatorService.h"




GraphQueryAggregatorService_init_args::~GraphQueryAggregatorService_init_args() throw() {
}


uint32_t GraphQueryAggregatorService_init_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_init_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_init_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_init_pargs::~GraphQueryAggregatorService_init_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_init_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_init_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_init_result::~GraphQueryAggregatorService_init_result() throw() {
}


uint32_t GraphQueryAggregatorService_init_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_init_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_init_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_init_presult::~GraphQueryAggregatorService_init_presult() throw() {
}


uint32_t GraphQueryAggregatorService_init_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_init_local_shards_args::~GraphQueryAggregatorService_init_local_shards_args() throw() {
}


uint32_t GraphQueryAggregatorService_init_local_shards_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_init_local_shards_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_init_local_shards_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_init_local_shards_pargs::~GraphQueryAggregatorService_init_local_shards_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_init_local_shards_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_init_local_shards_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_init_local_shards_result::~GraphQueryAggregatorService_init_local_shards_result() throw() {
}


uint32_t GraphQueryAggregatorService_init_local_shards_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_init_local_shards_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_init_local_shards_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_init_local_shards_presult::~GraphQueryAggregatorService_init_local_shards_presult() throw() {
}


uint32_t GraphQueryAggregatorService_init_local_shards_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_local_data_init_args::~GraphQueryAggregatorService_local_data_init_args() throw() {
}


uint32_t GraphQueryAggregatorService_local_data_init_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_local_data_init_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_local_data_init_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_local_data_init_pargs::~GraphQueryAggregatorService_local_data_init_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_local_data_init_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_local_data_init_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_local_data_init_result::~GraphQueryAggregatorService_local_data_init_result() throw() {
}


uint32_t GraphQueryAggregatorService_local_data_init_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_local_data_init_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_local_data_init_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_local_data_init_presult::~GraphQueryAggregatorService_local_data_init_presult() throw() {
}


uint32_t GraphQueryAggregatorService_local_data_init_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_connect_to_aggregators_args::~GraphQueryAggregatorService_connect_to_aggregators_args() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_aggregators_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_connect_to_aggregators_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_connect_to_aggregators_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_connect_to_aggregators_pargs::~GraphQueryAggregatorService_connect_to_aggregators_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_aggregators_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_connect_to_aggregators_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_connect_to_aggregators_result::~GraphQueryAggregatorService_connect_to_aggregators_result() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_aggregators_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_connect_to_aggregators_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_connect_to_aggregators_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_connect_to_aggregators_presult::~GraphQueryAggregatorService_connect_to_aggregators_presult() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_aggregators_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_connect_to_local_shards_args::~GraphQueryAggregatorService_connect_to_local_shards_args() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_local_shards_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_connect_to_local_shards_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_connect_to_local_shards_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_connect_to_local_shards_pargs::~GraphQueryAggregatorService_connect_to_local_shards_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_local_shards_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_connect_to_local_shards_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_connect_to_local_shards_result::~GraphQueryAggregatorService_connect_to_local_shards_result() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_local_shards_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_connect_to_local_shards_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_connect_to_local_shards_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_connect_to_local_shards_presult::~GraphQueryAggregatorService_connect_to_local_shards_presult() throw() {
}


uint32_t GraphQueryAggregatorService_connect_to_local_shards_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_shutdown_args::~GraphQueryAggregatorService_shutdown_args() throw() {
}


uint32_t GraphQueryAggregatorService_shutdown_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_shutdown_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_shutdown_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_shutdown_pargs::~GraphQueryAggregatorService_shutdown_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_shutdown_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_shutdown_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_shutdown_result::~GraphQueryAggregatorService_shutdown_result() throw() {
}


uint32_t GraphQueryAggregatorService_shutdown_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_shutdown_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_shutdown_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_shutdown_presult::~GraphQueryAggregatorService_shutdown_presult() throw() {
}


uint32_t GraphQueryAggregatorService_shutdown_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_disconnect_from_local_shards_args::~GraphQueryAggregatorService_disconnect_from_local_shards_args() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_local_shards_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_disconnect_from_local_shards_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_disconnect_from_local_shards_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_disconnect_from_local_shards_pargs::~GraphQueryAggregatorService_disconnect_from_local_shards_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_local_shards_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_disconnect_from_local_shards_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_disconnect_from_local_shards_result::~GraphQueryAggregatorService_disconnect_from_local_shards_result() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_local_shards_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_disconnect_from_local_shards_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_disconnect_from_local_shards_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_disconnect_from_local_shards_presult::~GraphQueryAggregatorService_disconnect_from_local_shards_presult() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_local_shards_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_disconnect_from_aggregators_args::~GraphQueryAggregatorService_disconnect_from_aggregators_args() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_aggregators_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_disconnect_from_aggregators_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_disconnect_from_aggregators_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_disconnect_from_aggregators_pargs::~GraphQueryAggregatorService_disconnect_from_aggregators_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_aggregators_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_disconnect_from_aggregators_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_disconnect_from_aggregators_result::~GraphQueryAggregatorService_disconnect_from_aggregators_result() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_aggregators_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_disconnect_from_aggregators_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_disconnect_from_aggregators_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_disconnect_from_aggregators_presult::~GraphQueryAggregatorService_disconnect_from_aggregators_presult() throw() {
}


uint32_t GraphQueryAggregatorService_disconnect_from_aggregators_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_backfill_edge_updates_args::~GraphQueryAggregatorService_backfill_edge_updates_args() throw() {
}


uint32_t GraphQueryAggregatorService_backfill_edge_updates_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_backfill_edge_updates_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_backfill_edge_updates_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_backfill_edge_updates_pargs::~GraphQueryAggregatorService_backfill_edge_updates_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_backfill_edge_updates_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_backfill_edge_updates_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_backfill_edge_updates_result::~GraphQueryAggregatorService_backfill_edge_updates_result() throw() {
}


uint32_t GraphQueryAggregatorService_backfill_edge_updates_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_backfill_edge_updates_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_backfill_edge_updates_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_backfill_edge_updates_presult::~GraphQueryAggregatorService_backfill_edge_updates_presult() throw() {
}


uint32_t GraphQueryAggregatorService_backfill_edge_updates_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_record_edge_updates_args::~GraphQueryAggregatorService_record_edge_updates_args() throw() {
}


uint32_t GraphQueryAggregatorService_record_edge_updates_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->next_shard);
          this->__isset.next_shard = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->local_shard);
          this->__isset.local_shard = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size161;
            ::apache::thrift::protocol::TType _etype164;
            xfer += iprot->readListBegin(_etype164, _size161);
            this->updates.resize(_size161);
            uint32_t _i165;
            for (_i165 = 0; _i165 < _size161; ++_i165)
            {
              xfer += this->updates[_i165].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_record_edge_updates_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_record_edge_updates_args");

  xfer += oprot->writeFieldBegin("next_shard", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->next_shard);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("local_shard", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->local_shard);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
    std::vector<ThriftSrcAtype> ::const_iterator _iter166;
    for (_iter166 = this->updates.begin(); _iter166 != this->updates.end(); ++_iter166)
    {
      xfer += (*_iter166).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_record_edge_updates_pargs::~GraphQueryAggregatorService_record_edge_updates_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_record_edge_updates_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_record_edge_updates_pargs");

  xfer += oprot->writeFieldBegin("next_shard", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->next_shard)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("local_shard", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->local_shard)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->updates)).size()));
    std::vector<ThriftSrcAtype> ::const_iterator _iter167;
    for (_iter167 = (*(this->updates)).begin(); _iter167 != (*(this->updates)).end(); ++_iter167)
    {
      xfer += (*_iter167).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_record_edge_updates_result::~GraphQueryAggregatorService_record_edge_updates_result() throw() {
}


uint32_t GraphQueryAggregatorService_record_edge_updates_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_record_edge_updates_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_record_edge_updates_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_record_edge_updates_presult::~GraphQueryAggregatorService_record_edge_updates_presult() throw() {
}


uint32_t GraphQueryAggregatorService_record_edge_updates_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_attribute_args::~GraphQueryAggregatorService_get_attribute_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId);
          this->__isset.attrId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_attribute_args");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->attrId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_attribute_pargs::~GraphQueryAggregatorService_get_attribute_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_attribute_pargs");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->attrId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_attribute_result::~GraphQueryAggregatorService_get_attribute_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_attribute_presult::~GraphQueryAggregatorService_get_attribute_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_attribute_local_args::~GraphQueryAggregatorService_get_attribute_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId);
          this->__isset.attrId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_attribute_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_attribute_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->attrId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_attribute_local_pargs::~GraphQueryAggregatorService_get_attribute_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_attribute_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->attrId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_attribute_local_result::~GraphQueryAggregatorService_get_attribute_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_attribute_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_attribute_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_attribute_local_presult::~GraphQueryAggregatorService_get_attribute_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_attribute_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_neighbors_args::~GraphQueryAggregatorService_get_neighbors_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_args");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_pargs::~GraphQueryAggregatorService_get_neighbors_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_pargs");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_result::~GraphQueryAggregatorService_get_neighbors_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size168;
            ::apache::thrift::protocol::TType _etype171;
            xfer += iprot->readListBegin(_etype171, _size168);
            this->success.resize(_size168);
            uint32_t _i172;
            for (_i172 = 0; _i172 < _size168; ++_i172)
            {
              xfer += iprot->readI64(this->success[_i172]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter173;
      for (_iter173 = this->success.begin(); _iter173 != this->success.end(); ++_iter173)
      {
        xfer += oprot->writeI64((*_iter173));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_presult::~GraphQueryAggregatorService_get_neighbors_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            (*(this->success)).resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += iprot->readI64((*(this->success))[_i178]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_neighbors_local_args::~GraphQueryAggregatorService_get_neighbors_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_local_pargs::~GraphQueryAggregatorService_get_neighbors_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_local_result::~GraphQueryAggregatorService_get_neighbors_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size179);
            this->success.resize(_size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              xfer += iprot->readI64(this->success[_i183]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter184;
      for (_iter184 = this->success.begin(); _iter184 != this->success.end(); ++_iter184)
      {
        xfer += oprot->writeI64((*_iter184));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_local_presult::~GraphQueryAggregatorService_get_neighbors_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            (*(this->success)).resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += iprot->readI64((*(this->success))[_i189]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_args::~GraphQueryAggregatorService_get_neighbors_atype_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_atype_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_atype_args");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_pargs::~GraphQueryAggregatorService_get_neighbors_atype_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_atype_pargs");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_result::~GraphQueryAggregatorService_get_neighbors_atype_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->success.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += iprot->readI64(this->success[_i194]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_atype_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_atype_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter195;
      for (_iter195 = this->success.begin(); _iter195 != this->success.end(); ++_iter195)
      {
        xfer += oprot->writeI64((*_iter195));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_presult::~GraphQueryAggregatorService_get_neighbors_atype_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size196;
            ::apache::thrift::protocol::TType _etype199;
            xfer += iprot->readListBegin(_etype199, _size196);
            (*(this->success)).resize(_size196);
            uint32_t _i200;
            for (_i200 = 0; _i200 < _size196; ++_i200)
            {
              xfer += iprot->readI64((*(this->success))[_i200]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_local_args::~GraphQueryAggregatorService_get_neighbors_atype_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_atype_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_atype_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_local_pargs::~GraphQueryAggregatorService_get_neighbors_atype_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_atype_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_local_result::~GraphQueryAggregatorService_get_neighbors_atype_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size201;
            ::apache::thrift::protocol::TType _etype204;
            xfer += iprot->readListBegin(_etype204, _size201);
            this->success.resize(_size201);
            uint32_t _i205;
            for (_i205 = 0; _i205 < _size201; ++_i205)
            {
              xfer += iprot->readI64(this->success[_i205]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_atype_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_atype_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter206;
      for (_iter206 = this->success.begin(); _iter206 != this->success.end(); ++_iter206)
      {
        xfer += oprot->writeI64((*_iter206));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_atype_local_presult::~GraphQueryAggregatorService_get_neighbors_atype_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_atype_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            (*(this->success)).resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += iprot->readI64((*(this->success))[_i211]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_args::~GraphQueryAggregatorService_get_neighbors_attr_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId);
          this->__isset.attrId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey);
          this->__isset.attrKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_attr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_attr_args");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->attrId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->attrKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_pargs::~GraphQueryAggregatorService_get_neighbors_attr_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_attr_pargs");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->attrId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->attrKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_result::~GraphQueryAggregatorService_get_neighbors_attr_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _etype215;
            xfer += iprot->readListBegin(_etype215, _size212);
            this->success.resize(_size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              xfer += iprot->readI64(this->success[_i216]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_attr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_attr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter217;
      for (_iter217 = this->success.begin(); _iter217 != this->success.end(); ++_iter217)
      {
        xfer += oprot->writeI64((*_iter217));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_presult::~GraphQueryAggregatorService_get_neighbors_attr_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size218;
            ::apache::thrift::protocol::TType _etype221;
            xfer += iprot->readListBegin(_etype221, _size218);
            (*(this->success)).resize(_size218);
            uint32_t _i222;
            for (_i222 = 0; _i222 < _size218; ++_i222)
            {
              xfer += iprot->readI64((*(this->success))[_i222]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_local_args::~GraphQueryAggregatorService_get_neighbors_attr_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId);
          this->__isset.attrId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey);
          this->__isset.attrKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_attr_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_attr_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->attrId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->attrKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_local_pargs::~GraphQueryAggregatorService_get_neighbors_attr_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_attr_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->attrId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->attrKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_local_result::~GraphQueryAggregatorService_get_neighbors_attr_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size223;
            ::apache::thrift::protocol::TType _etype226;
            xfer += iprot->readListBegin(_etype226, _size223);
            this->success.resize(_size223);
            uint32_t _i227;
            for (_i227 = 0; _i227 < _size223; ++_i227)
            {
              xfer += iprot->readI64(this->success[_i227]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_neighbors_attr_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_neighbors_attr_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter228;
      for (_iter228 = this->success.begin(); _iter228 != this->success.end(); ++_iter228)
      {
        xfer += oprot->writeI64((*_iter228));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_neighbors_attr_local_presult::~GraphQueryAggregatorService_get_neighbors_attr_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_neighbors_attr_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size229;
            ::apache::thrift::protocol::TType _etype232;
            xfer += iprot->readListBegin(_etype232, _size229);
            (*(this->success)).resize(_size229);
            uint32_t _i233;
            for (_i233 = 0; _i233 < _size229; ++_i233)
            {
              xfer += iprot->readI64((*(this->success))[_i233]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_nodes_args::~GraphQueryAggregatorService_get_nodes_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId);
          this->__isset.attrId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey);
          this->__isset.attrKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes_args");

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->attrId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->attrKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes_pargs::~GraphQueryAggregatorService_get_nodes_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes_pargs");

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->attrId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->attrKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes_result::~GraphQueryAggregatorService_get_nodes_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size234;
            ::apache::thrift::protocol::TType _etype237;
            xfer += iprot->readSetBegin(_etype237, _size234);
            uint32_t _i238;
            for (_i238 = 0; _i238 < _size234; ++_i238)
            {
              int64_t _elem239;
              xfer += iprot->readI64(_elem239);
              this->success.insert(_elem239);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::set<int64_t> ::const_iterator _iter240;
      for (_iter240 = this->success.begin(); _iter240 != this->success.end(); ++_iter240)
      {
        xfer += oprot->writeI64((*_iter240));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes_presult::~GraphQueryAggregatorService_get_nodes_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readSetBegin(_etype244, _size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              int64_t _elem246;
              xfer += iprot->readI64(_elem246);
              (*(this->success)).insert(_elem246);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_nodes_local_args::~GraphQueryAggregatorService_get_nodes_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId);
          this->__isset.attrId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey);
          this->__isset.attrKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes_local_args");

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->attrId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->attrKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes_local_pargs::~GraphQueryAggregatorService_get_nodes_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes_local_pargs");

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->attrId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->attrKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes_local_result::~GraphQueryAggregatorService_get_nodes_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _etype250;
            xfer += iprot->readSetBegin(_etype250, _size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251)
            {
              int64_t _elem252;
              xfer += iprot->readI64(_elem252);
              this->success.insert(_elem252);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::set<int64_t> ::const_iterator _iter253;
      for (_iter253 = this->success.begin(); _iter253 != this->success.end(); ++_iter253)
      {
        xfer += oprot->writeI64((*_iter253));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes_local_presult::~GraphQueryAggregatorService_get_nodes_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size254;
            ::apache::thrift::protocol::TType _etype257;
            xfer += iprot->readSetBegin(_etype257, _size254);
            uint32_t _i258;
            for (_i258 = 0; _i258 < _size254; ++_i258)
            {
              int64_t _elem259;
              xfer += iprot->readI64(_elem259);
              (*(this->success)).insert(_elem259);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_nodes2_args::~GraphQueryAggregatorService_get_nodes2_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId1);
          this->__isset.attrId1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey1);
          this->__isset.attrKey1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId2);
          this->__isset.attrId2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey2);
          this->__isset.attrKey2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes2_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes2_args");

  xfer += oprot->writeFieldBegin("attrId1", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->attrId1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->attrKey1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId2", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->attrId2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->attrKey2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes2_pargs::~GraphQueryAggregatorService_get_nodes2_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes2_pargs");

  xfer += oprot->writeFieldBegin("attrId1", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->attrId1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->attrKey1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId2", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->attrId2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->attrKey2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes2_result::~GraphQueryAggregatorService_get_nodes2_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size260;
            ::apache::thrift::protocol::TType _etype263;
            xfer += iprot->readSetBegin(_etype263, _size260);
            uint32_t _i264;
            for (_i264 = 0; _i264 < _size260; ++_i264)
            {
              int64_t _elem265;
              xfer += iprot->readI64(_elem265);
              this->success.insert(_elem265);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes2_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes2_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::set<int64_t> ::const_iterator _iter266;
      for (_iter266 = this->success.begin(); _iter266 != this->success.end(); ++_iter266)
      {
        xfer += oprot->writeI64((*_iter266));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes2_presult::~GraphQueryAggregatorService_get_nodes2_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readSetBegin(_etype270, _size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              int64_t _elem272;
              xfer += iprot->readI64(_elem272);
              (*(this->success)).insert(_elem272);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_nodes2_local_args::~GraphQueryAggregatorService_get_nodes2_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId1);
          this->__isset.attrId1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey1);
          this->__isset.attrKey1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId2);
          this->__isset.attrId2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey2);
          this->__isset.attrKey2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes2_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes2_local_args");

  xfer += oprot->writeFieldBegin("attrId1", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->attrId1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->attrKey1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId2", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->attrId2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->attrKey2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes2_local_pargs::~GraphQueryAggregatorService_get_nodes2_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes2_local_pargs");

  xfer += oprot->writeFieldBegin("attrId1", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->attrId1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->attrKey1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId2", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->attrId2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->attrKey2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes2_local_result::~GraphQueryAggregatorService_get_nodes2_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size273;
            ::apache::thrift::protocol::TType _etype276;
            xfer += iprot->readSetBegin(_etype276, _size273);
            uint32_t _i277;
            for (_i277 = 0; _i277 < _size273; ++_i277)
            {
              int64_t _elem278;
              xfer += iprot->readI64(_elem278);
              this->success.insert(_elem278);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_nodes2_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_nodes2_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::set<int64_t> ::const_iterator _iter279;
      for (_iter279 = this->success.begin(); _iter279 != this->success.end(); ++_iter279)
      {
        xfer += oprot->writeI64((*_iter279));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_nodes2_local_presult::~GraphQueryAggregatorService_get_nodes2_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_nodes2_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size280;
            ::apache::thrift::protocol::TType _etype283;
            xfer += iprot->readSetBegin(_etype283, _size280);
            uint32_t _i284;
            for (_i284 = 0; _i284 < _size280; ++_i284)
            {
              int64_t _elem285;
              xfer += iprot->readI64(_elem285);
              (*(this->success)).insert(_elem285);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_filter_nodes_local_args::~GraphQueryAggregatorService_filter_nodes_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_filter_nodes_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodeIds.clear();
            uint32_t _size286;
            ::apache::thrift::protocol::TType _etype289;
            xfer += iprot->readListBegin(_etype289, _size286);
            this->nodeIds.resize(_size286);
            uint32_t _i290;
            for (_i290 = 0; _i290 < _size286; ++_i290)
            {
              xfer += iprot->readI64(this->nodeIds[_i290]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodeIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attrId);
          this->__isset.attrId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attrKey);
          this->__isset.attrKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_filter_nodes_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_filter_nodes_local_args");

  xfer += oprot->writeFieldBegin("nodeIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->nodeIds.size()));
    std::vector<int64_t> ::const_iterator _iter291;
    for (_iter291 = this->nodeIds.begin(); _iter291 != this->nodeIds.end(); ++_iter291)
    {
      xfer += oprot->writeI64((*_iter291));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->attrId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->attrKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_filter_nodes_local_pargs::~GraphQueryAggregatorService_filter_nodes_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_filter_nodes_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_filter_nodes_local_pargs");

  xfer += oprot->writeFieldBegin("nodeIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->nodeIds)).size()));
    std::vector<int64_t> ::const_iterator _iter292;
    for (_iter292 = (*(this->nodeIds)).begin(); _iter292 != (*(this->nodeIds)).end(); ++_iter292)
    {
      xfer += oprot->writeI64((*_iter292));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->attrId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrKey", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->attrKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_filter_nodes_local_result::~GraphQueryAggregatorService_filter_nodes_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_filter_nodes_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size293;
            ::apache::thrift::protocol::TType _etype296;
            xfer += iprot->readListBegin(_etype296, _size293);
            this->success.resize(_size293);
            uint32_t _i297;
            for (_i297 = 0; _i297 < _size293; ++_i297)
            {
              xfer += iprot->readI64(this->success[_i297]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_filter_nodes_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_filter_nodes_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter298;
      for (_iter298 = this->success.begin(); _iter298 != this->success.end(); ++_iter298)
      {
        xfer += oprot->writeI64((*_iter298));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_filter_nodes_local_presult::~GraphQueryAggregatorService_filter_nodes_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_filter_nodes_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size299;
            ::apache::thrift::protocol::TType _etype302;
            xfer += iprot->readListBegin(_etype302, _size299);
            (*(this->success)).resize(_size299);
            uint32_t _i303;
            for (_i303 = 0; _i303 < _size299; ++_i303)
            {
              xfer += iprot->readI64((*(this->success))[_i303]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_args::~GraphQueryAggregatorService_get_edge_attrs_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_edge_attrs_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_edge_attrs_args");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_pargs::~GraphQueryAggregatorService_get_edge_attrs_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_edge_attrs_pargs");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_result::~GraphQueryAggregatorService_get_edge_attrs_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size304;
            ::apache::thrift::protocol::TType _etype307;
            xfer += iprot->readListBegin(_etype307, _size304);
            this->success.resize(_size304);
            uint32_t _i308;
            for (_i308 = 0; _i308 < _size304; ++_i308)
            {
              xfer += iprot->readString(this->success[_i308]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_edge_attrs_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_edge_attrs_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter309;
      for (_iter309 = this->success.begin(); _iter309 != this->success.end(); ++_iter309)
      {
        xfer += oprot->writeString((*_iter309));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_presult::~GraphQueryAggregatorService_get_edge_attrs_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size310;
            ::apache::thrift::protocol::TType _etype313;
            xfer += iprot->readListBegin(_etype313, _size310);
            (*(this->success)).resize(_size310);
            uint32_t _i314;
            for (_i314 = 0; _i314 < _size310; ++_i314)
            {
              xfer += iprot->readString((*(this->success))[_i314]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_local_args::~GraphQueryAggregatorService_get_edge_attrs_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_edge_attrs_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_edge_attrs_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_local_pargs::~GraphQueryAggregatorService_get_edge_attrs_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_edge_attrs_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_local_result::~GraphQueryAggregatorService_get_edge_attrs_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size315;
            ::apache::thrift::protocol::TType _etype318;
            xfer += iprot->readListBegin(_etype318, _size315);
            this->success.resize(_size315);
            uint32_t _i319;
            for (_i319 = 0; _i319 < _size315; ++_i319)
            {
              xfer += iprot->readString(this->success[_i319]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_get_edge_attrs_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_get_edge_attrs_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter320;
      for (_iter320 = this->success.begin(); _iter320 != this->success.end(); ++_iter320)
      {
        xfer += oprot->writeString((*_iter320));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_get_edge_attrs_local_presult::~GraphQueryAggregatorService_get_edge_attrs_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_get_edge_attrs_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            (*(this->success)).resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += iprot->readString((*(this->success))[_i325]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_range_args::~GraphQueryAggregatorService_assoc_range_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->off);
          this->__isset.off = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_range_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("off", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->off);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->len);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_pargs::~GraphQueryAggregatorService_assoc_range_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("off", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->off)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->len)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_result::~GraphQueryAggregatorService_assoc_range_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size326;
            ::apache::thrift::protocol::TType _etype329;
            xfer += iprot->readListBegin(_etype329, _size326);
            this->success.resize(_size326);
            uint32_t _i330;
            for (_i330 = 0; _i330 < _size326; ++_i330)
            {
              xfer += this->success[_i330].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_range_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ThriftAssoc> ::const_iterator _iter331;
      for (_iter331 = this->success.begin(); _iter331 != this->success.end(); ++_iter331)
      {
        xfer += (*_iter331).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_presult::~GraphQueryAggregatorService_assoc_range_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size332;
            ::apache::thrift::protocol::TType _etype335;
            xfer += iprot->readListBegin(_etype335, _size332);
            (*(this->success)).resize(_size332);
            uint32_t _i336;
            for (_i336 = 0; _i336 < _size332; ++_i336)
            {
              xfer += (*(this->success))[_i336].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_range_batched_args::~GraphQueryAggregatorService_assoc_range_batched_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_batched_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src.clear();
            uint32_t _size337;
            ::apache::thrift::protocol::TType _etype340;
            xfer += iprot->readListBegin(_etype340, _size337);
            this->src.resize(_size337);
            uint32_t _i341;
            for (_i341 = 0; _i341 < _size337; ++_i341)
            {
              xfer += iprot->readI64(this->src[_i341]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->atype.clear();
            uint32_t _size342;
            ::apache::thrift::protocol::TType _etype345;
            xfer += iprot->readListBegin(_etype345, _size342);
            this->atype.resize(_size342);
            uint32_t _i346;
            for (_i346 = 0; _i346 < _size342; ++_i346)
            {
              xfer += iprot->readI64(this->atype[_i346]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->off.clear();
            uint32_t _size347;
            ::apache::thrift::protocol::TType _etype350;
            xfer += iprot->readListBegin(_etype350, _size347);
            this->off.resize(_size347);
            uint32_t _i351;
            for (_i351 = 0; _i351 < _size347; ++_i351)
            {
              xfer += iprot->readI32(this->off[_i351]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.off = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->len.clear();
            uint32_t _size352;
            ::apache::thrift::protocol::TType _etype355;
            xfer += iprot->readListBegin(_etype355, _size352);
            this->len.resize(_size352);
            uint32_t _i356;
            for (_i356 = 0; _i356 < _size352; ++_i356)
            {
              xfer += iprot->readI32(this->len[_i356]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_range_batched_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_batched_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->src.size()));
    std::vector<int64_t> ::const_iterator _iter357;
    for (_iter357 = this->src.begin(); _iter357 != this->src.end(); ++_iter357)
    {
      xfer += oprot->writeI64((*_iter357));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->atype.size()));
    std::vector<int64_t> ::const_iterator _iter358;
    for (_iter358 = this->atype.begin(); _iter358 != this->atype.end(); ++_iter358)
    {
      xfer += oprot->writeI64((*_iter358));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("off", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->off.size()));
    std::vector<int32_t> ::const_iterator _iter359;
    for (_iter359 = this->off.begin(); _iter359 != this->off.end(); ++_iter359)
    {
      xfer += oprot->writeI32((*_iter359));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->len.size()));
    std::vector<int32_t> ::const_iterator _iter360;
    for (_iter360 = this->len.begin(); _iter360 != this->len.end(); ++_iter360)
    {
      xfer += oprot->writeI32((*_iter360));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_batched_pargs::~GraphQueryAggregatorService_assoc_range_batched_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_batched_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_batched_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->src)).size()));
    std::vector<int64_t> ::const_iterator _iter361;
    for (_iter361 = (*(this->src)).begin(); _iter361 != (*(this->src)).end(); ++_iter361)
    {
      xfer += oprot->writeI64((*_iter361));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->atype)).size()));
    std::vector<int64_t> ::const_iterator _iter362;
    for (_iter362 = (*(this->atype)).begin(); _iter362 != (*(this->atype)).end(); ++_iter362)
    {
      xfer += oprot->writeI64((*_iter362));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("off", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->off)).size()));
    std::vector<int32_t> ::const_iterator _iter363;
    for (_iter363 = (*(this->off)).begin(); _iter363 != (*(this->off)).end(); ++_iter363)
    {
      xfer += oprot->writeI32((*_iter363));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->len)).size()));
    std::vector<int32_t> ::const_iterator _iter364;
    for (_iter364 = (*(this->len)).begin(); _iter364 != (*(this->len)).end(); ++_iter364)
    {
      xfer += oprot->writeI32((*_iter364));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_batched_result::~GraphQueryAggregatorService_assoc_range_batched_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_batched_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size365;
            ::apache::thrift::protocol::TType _etype368;
            xfer += iprot->readListBegin(_etype368, _size365);
            this->success.resize(_size365);
            uint32_t _i369;
            for (_i369 = 0; _i369 < _size365; ++_i369)
            {
              {
                this->success[_i369].clear();
                uint32_t _size370;
                ::apache::thrift::protocol::TType _etype373;
                xfer += iprot->readListBegin(_etype373, _size370);
                this->success[_i369].resize(_size370);
                uint32_t _i374;
                for (_i374 = 0; _i374 < _size370; ++_i374)
                {
                  xfer += this->success[_i369][_i374].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_range_batched_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_batched_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::vector<std::vector<ThriftAssoc> > ::const_iterator _iter375;
      for (_iter375 = this->success.begin(); _iter375 != this->success.end(); ++_iter375)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter375).size()));
          std::vector<ThriftAssoc> ::const_iterator _iter376;
          for (_iter376 = (*_iter375).begin(); _iter376 != (*_iter375).end(); ++_iter376)
          {
            xfer += (*_iter376).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_batched_presult::~GraphQueryAggregatorService_assoc_range_batched_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_batched_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size377;
            ::apache::thrift::protocol::TType _etype380;
            xfer += iprot->readListBegin(_etype380, _size377);
            (*(this->success)).resize(_size377);
            uint32_t _i381;
            for (_i381 = 0; _i381 < _size377; ++_i381)
            {
              {
                (*(this->success))[_i381].clear();
                uint32_t _size382;
                ::apache::thrift::protocol::TType _etype385;
                xfer += iprot->readListBegin(_etype385, _size382);
                (*(this->success))[_i381].resize(_size382);
                uint32_t _i386;
                for (_i386 = 0; _i386 < _size382; ++_i386)
                {
                  xfer += (*(this->success))[_i381][_i386].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_range_local_args::~GraphQueryAggregatorService_assoc_range_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->off);
          this->__isset.off = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_range_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("off", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->off);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->len);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_local_pargs::~GraphQueryAggregatorService_assoc_range_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("off", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->off)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->len)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_local_result::~GraphQueryAggregatorService_assoc_range_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size387;
            ::apache::thrift::protocol::TType _etype390;
            xfer += iprot->readListBegin(_etype390, _size387);
            this->success.resize(_size387);
            uint32_t _i391;
            for (_i391 = 0; _i391 < _size387; ++_i391)
            {
              xfer += this->success[_i391].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_range_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_range_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ThriftAssoc> ::const_iterator _iter392;
      for (_iter392 = this->success.begin(); _iter392 != this->success.end(); ++_iter392)
      {
        xfer += (*_iter392).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_range_local_presult::~GraphQueryAggregatorService_assoc_range_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_range_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size393;
            ::apache::thrift::protocol::TType _etype396;
            xfer += iprot->readListBegin(_etype396, _size393);
            (*(this->success)).resize(_size393);
            uint32_t _i397;
            for (_i397 = 0; _i397 < _size393; ++_i397)
            {
              xfer += (*(this->success))[_i397].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_count_args::~GraphQueryAggregatorService_assoc_count_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_count_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_pargs::~GraphQueryAggregatorService_assoc_count_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_result::~GraphQueryAggregatorService_assoc_count_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_count_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_presult::~GraphQueryAggregatorService_assoc_count_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_count_batched_args::~GraphQueryAggregatorService_assoc_count_batched_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_batched_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src.clear();
            uint32_t _size398;
            ::apache::thrift::protocol::TType _etype401;
            xfer += iprot->readListBegin(_etype401, _size398);
            this->src.resize(_size398);
            uint32_t _i402;
            for (_i402 = 0; _i402 < _size398; ++_i402)
            {
              xfer += iprot->readI64(this->src[_i402]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->atype.clear();
            uint32_t _size403;
            ::apache::thrift::protocol::TType _etype406;
            xfer += iprot->readListBegin(_etype406, _size403);
            this->atype.resize(_size403);
            uint32_t _i407;
            for (_i407 = 0; _i407 < _size403; ++_i407)
            {
              xfer += iprot->readI64(this->atype[_i407]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_count_batched_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_batched_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->src.size()));
    std::vector<int64_t> ::const_iterator _iter408;
    for (_iter408 = this->src.begin(); _iter408 != this->src.end(); ++_iter408)
    {
      xfer += oprot->writeI64((*_iter408));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->atype.size()));
    std::vector<int64_t> ::const_iterator _iter409;
    for (_iter409 = this->atype.begin(); _iter409 != this->atype.end(); ++_iter409)
    {
      xfer += oprot->writeI64((*_iter409));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_batched_pargs::~GraphQueryAggregatorService_assoc_count_batched_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_batched_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_batched_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->src)).size()));
    std::vector<int64_t> ::const_iterator _iter410;
    for (_iter410 = (*(this->src)).begin(); _iter410 != (*(this->src)).end(); ++_iter410)
    {
      xfer += oprot->writeI64((*_iter410));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->atype)).size()));
    std::vector<int64_t> ::const_iterator _iter411;
    for (_iter411 = (*(this->atype)).begin(); _iter411 != (*(this->atype)).end(); ++_iter411)
    {
      xfer += oprot->writeI64((*_iter411));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_batched_result::~GraphQueryAggregatorService_assoc_count_batched_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_batched_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size412;
            ::apache::thrift::protocol::TType _etype415;
            xfer += iprot->readListBegin(_etype415, _size412);
            this->success.resize(_size412);
            uint32_t _i416;
            for (_i416 = 0; _i416 < _size412; ++_i416)
            {
              xfer += iprot->readI64(this->success[_i416]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_count_batched_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_batched_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter417;
      for (_iter417 = this->success.begin(); _iter417 != this->success.end(); ++_iter417)
      {
        xfer += oprot->writeI64((*_iter417));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_batched_presult::~GraphQueryAggregatorService_assoc_count_batched_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_batched_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size418;
            ::apache::thrift::protocol::TType _etype421;
            xfer += iprot->readListBegin(_etype421, _size418);
            (*(this->success)).resize(_size418);
            uint32_t _i422;
            for (_i422 = 0; _i422 < _size418; ++_i422)
            {
              xfer += iprot->readI64((*(this->success))[_i422]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_count_local_args::~GraphQueryAggregatorService_assoc_count_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_count_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_local_pargs::~GraphQueryAggregatorService_assoc_count_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_local_result::~GraphQueryAggregatorService_assoc_count_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_count_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_count_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_count_local_presult::~GraphQueryAggregatorService_assoc_count_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_count_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_get_args::~GraphQueryAggregatorService_assoc_get_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->dstIdSet.clear();
            uint32_t _size423;
            ::apache::thrift::protocol::TType _etype426;
            xfer += iprot->readSetBegin(_etype426, _size423);
            uint32_t _i427;
            for (_i427 = 0; _i427 < _size423; ++_i427)
            {
              int64_t _elem428;
              xfer += iprot->readI64(_elem428);
              this->dstIdSet.insert(_elem428);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.dstIdSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tLow);
          this->__isset.tLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tHigh);
          this->__isset.tHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_get_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dstIdSet", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->dstIdSet.size()));
    std::set<int64_t> ::const_iterator _iter429;
    for (_iter429 = this->dstIdSet.begin(); _iter429 != this->dstIdSet.end(); ++_iter429)
    {
      xfer += oprot->writeI64((*_iter429));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->tLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->tHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_pargs::~GraphQueryAggregatorService_assoc_get_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dstIdSet", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->dstIdSet)).size()));
    std::set<int64_t> ::const_iterator _iter430;
    for (_iter430 = (*(this->dstIdSet)).begin(); _iter430 != (*(this->dstIdSet)).end(); ++_iter430)
    {
      xfer += oprot->writeI64((*_iter430));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->tLow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->tHigh)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_result::~GraphQueryAggregatorService_assoc_get_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size431;
            ::apache::thrift::protocol::TType _etype434;
            xfer += iprot->readListBegin(_etype434, _size431);
            this->success.resize(_size431);
            uint32_t _i435;
            for (_i435 = 0; _i435 < _size431; ++_i435)
            {
              xfer += this->success[_i435].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_get_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ThriftAssoc> ::const_iterator _iter436;
      for (_iter436 = this->success.begin(); _iter436 != this->success.end(); ++_iter436)
      {
        xfer += (*_iter436).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_presult::~GraphQueryAggregatorService_assoc_get_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size437;
            ::apache::thrift::protocol::TType _etype440;
            xfer += iprot->readListBegin(_etype440, _size437);
            (*(this->success)).resize(_size437);
            uint32_t _i441;
            for (_i441 = 0; _i441 < _size437; ++_i441)
            {
              xfer += (*(this->success))[_i441].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_get_batched_args::~GraphQueryAggregatorService_assoc_get_batched_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_batched_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src.clear();
            uint32_t _size442;
            ::apache::thrift::protocol::TType _etype445;
            xfer += iprot->readListBegin(_etype445, _size442);
            this->src.resize(_size442);
            uint32_t _i446;
            for (_i446 = 0; _i446 < _size442; ++_i446)
            {
              xfer += iprot->readI64(this->src[_i446]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->atype.clear();
            uint32_t _size447;
            ::apache::thrift::protocol::TType _etype450;
            xfer += iprot->readListBegin(_etype450, _size447);
            this->atype.resize(_size447);
            uint32_t _i451;
            for (_i451 = 0; _i451 < _size447; ++_i451)
            {
              xfer += iprot->readI64(this->atype[_i451]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dstIdSet.clear();
            uint32_t _size452;
            ::apache::thrift::protocol::TType _etype455;
            xfer += iprot->readListBegin(_etype455, _size452);
            this->dstIdSet.resize(_size452);
            uint32_t _i456;
            for (_i456 = 0; _i456 < _size452; ++_i456)
            {
              {
                this->dstIdSet[_i456].clear();
                uint32_t _size457;
                ::apache::thrift::protocol::TType _etype460;
                xfer += iprot->readSetBegin(_etype460, _size457);
                uint32_t _i461;
                for (_i461 = 0; _i461 < _size457; ++_i461)
                {
                  int64_t _elem462;
                  xfer += iprot->readI64(_elem462);
                  this->dstIdSet[_i456].insert(_elem462);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dstIdSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tLow.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->tLow.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              xfer += iprot->readI64(this->tLow[_i467]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tHigh.clear();
            uint32_t _size468;
            ::apache::thrift::protocol::TType _etype471;
            xfer += iprot->readListBegin(_etype471, _size468);
            this->tHigh.resize(_size468);
            uint32_t _i472;
            for (_i472 = 0; _i472 < _size468; ++_i472)
            {
              xfer += iprot->readI64(this->tHigh[_i472]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_get_batched_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_batched_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->src.size()));
    std::vector<int64_t> ::const_iterator _iter473;
    for (_iter473 = this->src.begin(); _iter473 != this->src.end(); ++_iter473)
    {
      xfer += oprot->writeI64((*_iter473));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->atype.size()));
    std::vector<int64_t> ::const_iterator _iter474;
    for (_iter474 = this->atype.begin(); _iter474 != this->atype.end(); ++_iter474)
    {
      xfer += oprot->writeI64((*_iter474));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dstIdSet", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->dstIdSet.size()));
    std::vector<std::set<int64_t> > ::const_iterator _iter475;
    for (_iter475 = this->dstIdSet.begin(); _iter475 != this->dstIdSet.end(); ++_iter475)
    {
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter475).size()));
        std::set<int64_t> ::const_iterator _iter476;
        for (_iter476 = (*_iter475).begin(); _iter476 != (*_iter475).end(); ++_iter476)
        {
          xfer += oprot->writeI64((*_iter476));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->tLow.size()));
    std::vector<int64_t> ::const_iterator _iter477;
    for (_iter477 = this->tLow.begin(); _iter477 != this->tLow.end(); ++_iter477)
    {
      xfer += oprot->writeI64((*_iter477));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->tHigh.size()));
    std::vector<int64_t> ::const_iterator _iter478;
    for (_iter478 = this->tHigh.begin(); _iter478 != this->tHigh.end(); ++_iter478)
    {
      xfer += oprot->writeI64((*_iter478));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_batched_pargs::~GraphQueryAggregatorService_assoc_get_batched_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_batched_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_batched_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->src)).size()));
    std::vector<int64_t> ::const_iterator _iter479;
    for (_iter479 = (*(this->src)).begin(); _iter479 != (*(this->src)).end(); ++_iter479)
    {
      xfer += oprot->writeI64((*_iter479));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->atype)).size()));
    std::vector<int64_t> ::const_iterator _iter480;
    for (_iter480 = (*(this->atype)).begin(); _iter480 != (*(this->atype)).end(); ++_iter480)
    {
      xfer += oprot->writeI64((*_iter480));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dstIdSet", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_SET, static_cast<uint32_t>((*(this->dstIdSet)).size()));
    std::vector<std::set<int64_t> > ::const_iterator _iter481;
    for (_iter481 = (*(this->dstIdSet)).begin(); _iter481 != (*(this->dstIdSet)).end(); ++_iter481)
    {
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter481).size()));
        std::set<int64_t> ::const_iterator _iter482;
        for (_iter482 = (*_iter481).begin(); _iter482 != (*_iter481).end(); ++_iter482)
        {
          xfer += oprot->writeI64((*_iter482));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->tLow)).size()));
    std::vector<int64_t> ::const_iterator _iter483;
    for (_iter483 = (*(this->tLow)).begin(); _iter483 != (*(this->tLow)).end(); ++_iter483)
    {
      xfer += oprot->writeI64((*_iter483));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->tHigh)).size()));
    std::vector<int64_t> ::const_iterator _iter484;
    for (_iter484 = (*(this->tHigh)).begin(); _iter484 != (*(this->tHigh)).end(); ++_iter484)
    {
      xfer += oprot->writeI64((*_iter484));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_batched_result::~GraphQueryAggregatorService_assoc_get_batched_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_batched_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size485;
            ::apache::thrift::protocol::TType _etype488;
            xfer += iprot->readListBegin(_etype488, _size485);
            this->success.resize(_size485);
            uint32_t _i489;
            for (_i489 = 0; _i489 < _size485; ++_i489)
            {
              {
                this->success[_i489].clear();
                uint32_t _size490;
                ::apache::thrift::protocol::TType _etype493;
                xfer += iprot->readListBegin(_etype493, _size490);
                this->success[_i489].resize(_size490);
                uint32_t _i494;
                for (_i494 = 0; _i494 < _size490; ++_i494)
                {
                  xfer += this->success[_i489][_i494].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_get_batched_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_batched_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::vector<std::vector<ThriftAssoc> > ::const_iterator _iter495;
      for (_iter495 = this->success.begin(); _iter495 != this->success.end(); ++_iter495)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter495).size()));
          std::vector<ThriftAssoc> ::const_iterator _iter496;
          for (_iter496 = (*_iter495).begin(); _iter496 != (*_iter495).end(); ++_iter496)
          {
            xfer += (*_iter496).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_batched_presult::~GraphQueryAggregatorService_assoc_get_batched_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_batched_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size497;
            ::apache::thrift::protocol::TType _etype500;
            xfer += iprot->readListBegin(_etype500, _size497);
            (*(this->success)).resize(_size497);
            uint32_t _i501;
            for (_i501 = 0; _i501 < _size497; ++_i501)
            {
              {
                (*(this->success))[_i501].clear();
                uint32_t _size502;
                ::apache::thrift::protocol::TType _etype505;
                xfer += iprot->readListBegin(_etype505, _size502);
                (*(this->success))[_i501].resize(_size502);
                uint32_t _i506;
                for (_i506 = 0; _i506 < _size502; ++_i506)
                {
                  xfer += (*(this->success))[_i501][_i506].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_get_local_args::~GraphQueryAggregatorService_assoc_get_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->dstIdSet.clear();
            uint32_t _size507;
            ::apache::thrift::protocol::TType _etype510;
            xfer += iprot->readSetBegin(_etype510, _size507);
            uint32_t _i511;
            for (_i511 = 0; _i511 < _size507; ++_i511)
            {
              int64_t _elem512;
              xfer += iprot->readI64(_elem512);
              this->dstIdSet.insert(_elem512);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.dstIdSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tLow);
          this->__isset.tLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tHigh);
          this->__isset.tHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_get_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dstIdSet", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->dstIdSet.size()));
    std::set<int64_t> ::const_iterator _iter513;
    for (_iter513 = this->dstIdSet.begin(); _iter513 != this->dstIdSet.end(); ++_iter513)
    {
      xfer += oprot->writeI64((*_iter513));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->tLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->tHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_local_pargs::~GraphQueryAggregatorService_assoc_get_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dstIdSet", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->dstIdSet)).size()));
    std::set<int64_t> ::const_iterator _iter514;
    for (_iter514 = (*(this->dstIdSet)).begin(); _iter514 != (*(this->dstIdSet)).end(); ++_iter514)
    {
      xfer += oprot->writeI64((*_iter514));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->tLow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64((*(this->tHigh)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_local_result::~GraphQueryAggregatorService_assoc_get_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size515;
            ::apache::thrift::protocol::TType _etype518;
            xfer += iprot->readListBegin(_etype518, _size515);
            this->success.resize(_size515);
            uint32_t _i519;
            for (_i519 = 0; _i519 < _size515; ++_i519)
            {
              xfer += this->success[_i519].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_get_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_get_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ThriftAssoc> ::const_iterator _iter520;
      for (_iter520 = this->success.begin(); _iter520 != this->success.end(); ++_iter520)
      {
        xfer += (*_iter520).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_get_local_presult::~GraphQueryAggregatorService_assoc_get_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_get_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size521;
            ::apache::thrift::protocol::TType _etype524;
            xfer += iprot->readListBegin(_etype524, _size521);
            (*(this->success)).resize(_size521);
            uint32_t _i525;
            for (_i525 = 0; _i525 < _size521; ++_i525)
            {
              xfer += (*(this->success))[_i525].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_obj_get_args::~GraphQueryAggregatorService_obj_get_args() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_obj_get_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_args");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_pargs::~GraphQueryAggregatorService_obj_get_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_pargs");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_result::~GraphQueryAggregatorService_obj_get_result() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size526;
            ::apache::thrift::protocol::TType _etype529;
            xfer += iprot->readListBegin(_etype529, _size526);
            this->success.resize(_size526);
            uint32_t _i530;
            for (_i530 = 0; _i530 < _size526; ++_i530)
            {
              xfer += iprot->readString(this->success[_i530]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_obj_get_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter531;
      for (_iter531 = this->success.begin(); _iter531 != this->success.end(); ++_iter531)
      {
        xfer += oprot->writeString((*_iter531));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_presult::~GraphQueryAggregatorService_obj_get_presult() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size532;
            ::apache::thrift::protocol::TType _etype535;
            xfer += iprot->readListBegin(_etype535, _size532);
            (*(this->success)).resize(_size532);
            uint32_t _i536;
            for (_i536 = 0; _i536 < _size532; ++_i536)
            {
              xfer += iprot->readString((*(this->success))[_i536]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_obj_get_batched_args::~GraphQueryAggregatorService_obj_get_batched_args() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_batched_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodeId.clear();
            uint32_t _size537;
            ::apache::thrift::protocol::TType _etype540;
            xfer += iprot->readListBegin(_etype540, _size537);
            this->nodeId.resize(_size537);
            uint32_t _i541;
            for (_i541 = 0; _i541 < _size537; ++_i541)
            {
              xfer += iprot->readI64(this->nodeId[_i541]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_obj_get_batched_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_batched_args");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->nodeId.size()));
    std::vector<int64_t> ::const_iterator _iter542;
    for (_iter542 = this->nodeId.begin(); _iter542 != this->nodeId.end(); ++_iter542)
    {
      xfer += oprot->writeI64((*_iter542));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_batched_pargs::~GraphQueryAggregatorService_obj_get_batched_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_batched_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_batched_pargs");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->nodeId)).size()));
    std::vector<int64_t> ::const_iterator _iter543;
    for (_iter543 = (*(this->nodeId)).begin(); _iter543 != (*(this->nodeId)).end(); ++_iter543)
    {
      xfer += oprot->writeI64((*_iter543));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_batched_result::~GraphQueryAggregatorService_obj_get_batched_result() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_batched_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size544;
            ::apache::thrift::protocol::TType _etype547;
            xfer += iprot->readListBegin(_etype547, _size544);
            this->success.resize(_size544);
            uint32_t _i548;
            for (_i548 = 0; _i548 < _size544; ++_i548)
            {
              {
                this->success[_i548].clear();
                uint32_t _size549;
                ::apache::thrift::protocol::TType _etype552;
                xfer += iprot->readListBegin(_etype552, _size549);
                this->success[_i548].resize(_size549);
                uint32_t _i553;
                for (_i553 = 0; _i553 < _size549; ++_i553)
                {
                  xfer += iprot->readString(this->success[_i548][_i553]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_obj_get_batched_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_batched_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::vector<std::vector<std::string> > ::const_iterator _iter554;
      for (_iter554 = this->success.begin(); _iter554 != this->success.end(); ++_iter554)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter554).size()));
          std::vector<std::string> ::const_iterator _iter555;
          for (_iter555 = (*_iter554).begin(); _iter555 != (*_iter554).end(); ++_iter555)
          {
            xfer += oprot->writeString((*_iter555));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_batched_presult::~GraphQueryAggregatorService_obj_get_batched_presult() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_batched_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size556;
            ::apache::thrift::protocol::TType _etype559;
            xfer += iprot->readListBegin(_etype559, _size556);
            (*(this->success)).resize(_size556);
            uint32_t _i560;
            for (_i560 = 0; _i560 < _size556; ++_i560)
            {
              {
                (*(this->success))[_i560].clear();
                uint32_t _size561;
                ::apache::thrift::protocol::TType _etype564;
                xfer += iprot->readListBegin(_etype564, _size561);
                (*(this->success))[_i560].resize(_size561);
                uint32_t _i565;
                for (_i565 = 0; _i565 < _size561; ++_i565)
                {
                  xfer += iprot->readString((*(this->success))[_i560][_i565]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_obj_get_local_args::~GraphQueryAggregatorService_obj_get_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nodeId);
          this->__isset.nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_obj_get_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_local_pargs::~GraphQueryAggregatorService_obj_get_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->nodeId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_local_result::~GraphQueryAggregatorService_obj_get_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size566;
            ::apache::thrift::protocol::TType _etype569;
            xfer += iprot->readListBegin(_etype569, _size566);
            this->success.resize(_size566);
            uint32_t _i570;
            for (_i570 = 0; _i570 < _size566; ++_i570)
            {
              xfer += iprot->readString(this->success[_i570]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_obj_get_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_obj_get_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter571;
      for (_iter571 = this->success.begin(); _iter571 != this->success.end(); ++_iter571)
      {
        xfer += oprot->writeString((*_iter571));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_obj_get_local_presult::~GraphQueryAggregatorService_obj_get_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_obj_get_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size572;
            ::apache::thrift::protocol::TType _etype575;
            xfer += iprot->readListBegin(_etype575, _size572);
            (*(this->success)).resize(_size572);
            uint32_t _i576;
            for (_i576 = 0; _i576 < _size572; ++_i576)
            {
              xfer += iprot->readString((*(this->success))[_i576]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_args::~GraphQueryAggregatorService_assoc_time_range_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tLow);
          this->__isset.tLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tHigh);
          this->__isset.tHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_time_range_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->tLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->tHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_pargs::~GraphQueryAggregatorService_assoc_time_range_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->tLow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->tHigh)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_result::~GraphQueryAggregatorService_assoc_time_range_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size577;
            ::apache::thrift::protocol::TType _etype580;
            xfer += iprot->readListBegin(_etype580, _size577);
            this->success.resize(_size577);
            uint32_t _i581;
            for (_i581 = 0; _i581 < _size577; ++_i581)
            {
              xfer += this->success[_i581].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_time_range_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ThriftAssoc> ::const_iterator _iter582;
      for (_iter582 = this->success.begin(); _iter582 != this->success.end(); ++_iter582)
      {
        xfer += (*_iter582).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_presult::~GraphQueryAggregatorService_assoc_time_range_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size583;
            ::apache::thrift::protocol::TType _etype586;
            xfer += iprot->readListBegin(_etype586, _size583);
            (*(this->success)).resize(_size583);
            uint32_t _i587;
            for (_i587 = 0; _i587 < _size583; ++_i587)
            {
              xfer += (*(this->success))[_i587].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_batched_args::~GraphQueryAggregatorService_assoc_time_range_batched_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_batched_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src.clear();
            uint32_t _size588;
            ::apache::thrift::protocol::TType _etype591;
            xfer += iprot->readListBegin(_etype591, _size588);
            this->src.resize(_size588);
            uint32_t _i592;
            for (_i592 = 0; _i592 < _size588; ++_i592)
            {
              xfer += iprot->readI64(this->src[_i592]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->atype.clear();
            uint32_t _size593;
            ::apache::thrift::protocol::TType _etype596;
            xfer += iprot->readListBegin(_etype596, _size593);
            this->atype.resize(_size593);
            uint32_t _i597;
            for (_i597 = 0; _i597 < _size593; ++_i597)
            {
              xfer += iprot->readI64(this->atype[_i597]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tLow.clear();
            uint32_t _size598;
            ::apache::thrift::protocol::TType _etype601;
            xfer += iprot->readListBegin(_etype601, _size598);
            this->tLow.resize(_size598);
            uint32_t _i602;
            for (_i602 = 0; _i602 < _size598; ++_i602)
            {
              xfer += iprot->readI64(this->tLow[_i602]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tHigh.clear();
            uint32_t _size603;
            ::apache::thrift::protocol::TType _etype606;
            xfer += iprot->readListBegin(_etype606, _size603);
            this->tHigh.resize(_size603);
            uint32_t _i607;
            for (_i607 = 0; _i607 < _size603; ++_i607)
            {
              xfer += iprot->readI64(this->tHigh[_i607]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->limit.clear();
            uint32_t _size608;
            ::apache::thrift::protocol::TType _etype611;
            xfer += iprot->readListBegin(_etype611, _size608);
            this->limit.resize(_size608);
            uint32_t _i612;
            for (_i612 = 0; _i612 < _size608; ++_i612)
            {
              xfer += iprot->readI32(this->limit[_i612]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_time_range_batched_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_batched_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->src.size()));
    std::vector<int64_t> ::const_iterator _iter613;
    for (_iter613 = this->src.begin(); _iter613 != this->src.end(); ++_iter613)
    {
      xfer += oprot->writeI64((*_iter613));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->atype.size()));
    std::vector<int64_t> ::const_iterator _iter614;
    for (_iter614 = this->atype.begin(); _iter614 != this->atype.end(); ++_iter614)
    {
      xfer += oprot->writeI64((*_iter614));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->tLow.size()));
    std::vector<int64_t> ::const_iterator _iter615;
    for (_iter615 = this->tLow.begin(); _iter615 != this->tLow.end(); ++_iter615)
    {
      xfer += oprot->writeI64((*_iter615));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->tHigh.size()));
    std::vector<int64_t> ::const_iterator _iter616;
    for (_iter616 = this->tHigh.begin(); _iter616 != this->tHigh.end(); ++_iter616)
    {
      xfer += oprot->writeI64((*_iter616));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->limit.size()));
    std::vector<int32_t> ::const_iterator _iter617;
    for (_iter617 = this->limit.begin(); _iter617 != this->limit.end(); ++_iter617)
    {
      xfer += oprot->writeI32((*_iter617));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_batched_pargs::~GraphQueryAggregatorService_assoc_time_range_batched_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_batched_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_batched_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->src)).size()));
    std::vector<int64_t> ::const_iterator _iter618;
    for (_iter618 = (*(this->src)).begin(); _iter618 != (*(this->src)).end(); ++_iter618)
    {
      xfer += oprot->writeI64((*_iter618));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->atype)).size()));
    std::vector<int64_t> ::const_iterator _iter619;
    for (_iter619 = (*(this->atype)).begin(); _iter619 != (*(this->atype)).end(); ++_iter619)
    {
      xfer += oprot->writeI64((*_iter619));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->tLow)).size()));
    std::vector<int64_t> ::const_iterator _iter620;
    for (_iter620 = (*(this->tLow)).begin(); _iter620 != (*(this->tLow)).end(); ++_iter620)
    {
      xfer += oprot->writeI64((*_iter620));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->tHigh)).size()));
    std::vector<int64_t> ::const_iterator _iter621;
    for (_iter621 = (*(this->tHigh)).begin(); _iter621 != (*(this->tHigh)).end(); ++_iter621)
    {
      xfer += oprot->writeI64((*_iter621));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->limit)).size()));
    std::vector<int32_t> ::const_iterator _iter622;
    for (_iter622 = (*(this->limit)).begin(); _iter622 != (*(this->limit)).end(); ++_iter622)
    {
      xfer += oprot->writeI32((*_iter622));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_batched_result::~GraphQueryAggregatorService_assoc_time_range_batched_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_batched_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size623;
            ::apache::thrift::protocol::TType _etype626;
            xfer += iprot->readListBegin(_etype626, _size623);
            this->success.resize(_size623);
            uint32_t _i627;
            for (_i627 = 0; _i627 < _size623; ++_i627)
            {
              {
                this->success[_i627].clear();
                uint32_t _size628;
                ::apache::thrift::protocol::TType _etype631;
                xfer += iprot->readListBegin(_etype631, _size628);
                this->success[_i627].resize(_size628);
                uint32_t _i632;
                for (_i632 = 0; _i632 < _size628; ++_i632)
                {
                  xfer += this->success[_i627][_i632].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_time_range_batched_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_batched_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::vector<std::vector<ThriftAssoc> > ::const_iterator _iter633;
      for (_iter633 = this->success.begin(); _iter633 != this->success.end(); ++_iter633)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter633).size()));
          std::vector<ThriftAssoc> ::const_iterator _iter634;
          for (_iter634 = (*_iter633).begin(); _iter634 != (*_iter633).end(); ++_iter634)
          {
            xfer += (*_iter634).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_batched_presult::~GraphQueryAggregatorService_assoc_time_range_batched_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_batched_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size635;
            ::apache::thrift::protocol::TType _etype638;
            xfer += iprot->readListBegin(_etype638, _size635);
            (*(this->success)).resize(_size635);
            uint32_t _i639;
            for (_i639 = 0; _i639 < _size635; ++_i639)
            {
              {
                (*(this->success))[_i639].clear();
                uint32_t _size640;
                ::apache::thrift::protocol::TType _etype643;
                xfer += iprot->readListBegin(_etype643, _size640);
                (*(this->success))[_i639].resize(_size640);
                uint32_t _i644;
                for (_i644 = 0; _i644 < _size640; ++_i644)
                {
                  xfer += (*(this->success))[_i639][_i644].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_local_args::~GraphQueryAggregatorService_assoc_time_range_local_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_local_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shardId);
          this->__isset.shardId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tLow);
          this->__isset.tLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tHigh);
          this->__isset.tHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_time_range_local_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_local_args");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->shardId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->tLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->tHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_local_pargs::~GraphQueryAggregatorService_assoc_time_range_local_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_local_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_local_pargs");

  xfer += oprot->writeFieldBegin("shardId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->shardId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tLow", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->tLow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tHigh", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->tHigh)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_local_result::~GraphQueryAggregatorService_assoc_time_range_local_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_local_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size645;
            ::apache::thrift::protocol::TType _etype648;
            xfer += iprot->readListBegin(_etype648, _size645);
            this->success.resize(_size645);
            uint32_t _i649;
            for (_i649 = 0; _i649 < _size645; ++_i649)
            {
              xfer += this->success[_i649].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_time_range_local_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_time_range_local_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ThriftAssoc> ::const_iterator _iter650;
      for (_iter650 = this->success.begin(); _iter650 != this->success.end(); ++_iter650)
      {
        xfer += (*_iter650).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_time_range_local_presult::~GraphQueryAggregatorService_assoc_time_range_local_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_time_range_local_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size651;
            ::apache::thrift::protocol::TType _etype654;
            xfer += iprot->readListBegin(_etype654, _size651);
            (*(this->success)).resize(_size651);
            uint32_t _i655;
            for (_i655 = 0; _i655 < _size651; ++_i655)
            {
              xfer += (*(this->success))[_i655].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


GraphQueryAggregatorService_assoc_add_args::~GraphQueryAggregatorService_assoc_add_args() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_add_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->atype);
          this->__isset.atype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dst);
          this->__isset.dst = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attr);
          this->__isset.attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_add_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_add_args");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->atype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dst", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->dst);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attr", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->attr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_add_pargs::~GraphQueryAggregatorService_assoc_add_pargs() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_add_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_add_pargs");

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->src)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->atype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dst", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->dst)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->time)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attr", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->attr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_add_result::~GraphQueryAggregatorService_assoc_add_result() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_add_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GraphQueryAggregatorService_assoc_add_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("GraphQueryAggregatorService_assoc_add_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


GraphQueryAggregatorService_assoc_add_presult::~GraphQueryAggregatorService_assoc_add_presult() throw() {
}


uint32_t GraphQueryAggregatorService_assoc_add_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

int32_t GraphQueryAggregatorServiceClient::init()
{
  send_init();
  return recv_init();
}

void GraphQueryAggregatorServiceClient::send_init()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("init", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_init_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t GraphQueryAggregatorServiceClient::recv_init()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("init") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  GraphQueryAggregatorService_init_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "init failed: unknown result");
}

int32_t GraphQueryAggregatorServiceClient::init_local_shards()
{
  send_init_local_shards();
  return recv_init_local_shards();
}

void GraphQueryAggregatorServiceClient::send_init_local_shards()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("init_local_shards", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_init_local_shards_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t GraphQueryAggregatorServiceClient::recv_init_local_shards()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("init_local_shards") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  GraphQueryAggregatorService_init_local_shards_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "init_local_shards failed: unknown result");
}

int32_t GraphQueryAggregatorServiceClient::local_data_init()
{
  send_local_data_init();
  return recv_local_data_init();
}

void GraphQueryAggregatorServiceClient::send_local_data_init()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("local_data_init", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_local_data_init_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t GraphQueryAggregatorServiceClient::recv_local_data_init()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("local_data_init") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  GraphQueryAggregatorService_local_data_init_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "local_data_init failed: unknown result");
}

int32_t GraphQueryAggregatorServiceClient::connect_to_aggregators()
{
  send_connect_to_aggregators();
  return recv_connect_to_aggregators();
}

void GraphQueryAggregatorServiceClient::send_connect_to_aggregators()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("connect_to_aggregators", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_connect_to_aggregators_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t GraphQueryAggregatorServiceClient::recv_connect_to_aggregators()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("connect_to_aggregators") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  GraphQueryAggregatorService_connect_to_aggregators_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect_to_aggregators failed: unknown result");
}

int32_t GraphQueryAggregatorServiceClient::connect_to_local_shards()
{
  send_connect_to_local_shards();
  return recv_connect_to_local_shards();
}

void GraphQueryAggregatorServiceClient::send_connect_to_local_shards()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("connect_to_local_shards", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_connect_to_local_shards_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t GraphQueryAggregatorServiceClient::recv_connect_to_local_shards()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("connect_to_local_shards") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  GraphQueryAggregatorService_connect_to_local_shards_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect_to_local_shards failed: unknown result");
}

void GraphQueryAggregatorServiceClient::shutdown()
{
  send_shutdown();
  recv_shutdown();
}

void GraphQueryAggregatorServiceClient::send_shutdown()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("shutdown", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_shutdown_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_shutdown()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("shutdown") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_shutdown_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void GraphQueryAggregatorServiceClient::disconnect_from_local_shards()
{
  send_disconnect_from_local_shards();
  recv_disconnect_from_local_shards();
}

void GraphQueryAggregatorServiceClient::send_disconnect_from_local_shards()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("disconnect_from_local_shards", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_disconnect_from_local_shards_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_disconnect_from_local_shards()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("disconnect_from_local_shards") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_disconnect_from_local_shards_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void GraphQueryAggregatorServiceClient::disconnect_from_aggregators()
{
  send_disconnect_from_aggregators();
  recv_disconnect_from_aggregators();
}

void GraphQueryAggregatorServiceClient::send_disconnect_from_aggregators()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("disconnect_from_aggregators", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_disconnect_from_aggregators_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_disconnect_from_aggregators()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("disconnect_from_aggregators") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_disconnect_from_aggregators_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

int32_t GraphQueryAggregatorServiceClient::backfill_edge_updates()
{
  send_backfill_edge_updates();
  return recv_backfill_edge_updates();
}

void GraphQueryAggregatorServiceClient::send_backfill_edge_updates()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("backfill_edge_updates", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_backfill_edge_updates_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t GraphQueryAggregatorServiceClient::recv_backfill_edge_updates()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("backfill_edge_updates") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  GraphQueryAggregatorService_backfill_edge_updates_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "backfill_edge_updates failed: unknown result");
}

void GraphQueryAggregatorServiceClient::record_edge_updates(const int32_t next_shard, const int32_t local_shard, const std::vector<ThriftSrcAtype> & updates)
{
  send_record_edge_updates(next_shard, local_shard, updates);
  recv_record_edge_updates();
}

void GraphQueryAggregatorServiceClient::send_record_edge_updates(const int32_t next_shard, const int32_t local_shard, const std::vector<ThriftSrcAtype> & updates)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("record_edge_updates", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_record_edge_updates_pargs args;
  args.next_shard = &next_shard;
  args.local_shard = &local_shard;
  args.updates = &updates;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_record_edge_updates()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("record_edge_updates") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_record_edge_updates_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void GraphQueryAggregatorServiceClient::get_attribute(std::string& _return, const int64_t nodeId, const int32_t attrId)
{
  send_get_attribute(nodeId, attrId);
  recv_get_attribute(_return);
}

void GraphQueryAggregatorServiceClient::send_get_attribute(const int64_t nodeId, const int32_t attrId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_attribute_pargs args;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_attribute(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_attribute failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_attribute_local(std::string& _return, const int64_t shardId, const int64_t nodeId, const int32_t attrId)
{
  send_get_attribute_local(shardId, nodeId, attrId);
  recv_get_attribute_local(_return);
}

void GraphQueryAggregatorServiceClient::send_get_attribute_local(const int64_t shardId, const int64_t nodeId, const int32_t attrId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_attribute_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_attribute_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_attribute_local(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_attribute_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_attribute_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_attribute_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_neighbors(std::vector<int64_t> & _return, const int64_t nodeId)
{
  send_get_neighbors(nodeId);
  recv_get_neighbors(_return);
}

void GraphQueryAggregatorServiceClient::send_get_neighbors(const int64_t nodeId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_neighbors", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_pargs args;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_neighbors(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_neighbors") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_neighbors_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_neighbors_local(std::vector<int64_t> & _return, const int32_t shardId, const int64_t nodeId)
{
  send_get_neighbors_local(shardId, nodeId);
  recv_get_neighbors_local(_return);
}

void GraphQueryAggregatorServiceClient::send_get_neighbors_local(const int32_t shardId, const int64_t nodeId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_neighbors_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_neighbors_local(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_neighbors_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_neighbors_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_neighbors_atype(std::vector<int64_t> & _return, const int64_t nodeId, const int64_t atype)
{
  send_get_neighbors_atype(nodeId, atype);
  recv_get_neighbors_atype(_return);
}

void GraphQueryAggregatorServiceClient::send_get_neighbors_atype(const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_neighbors_atype", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_atype_pargs args;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_neighbors_atype(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_neighbors_atype") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_neighbors_atype_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_atype failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_neighbors_atype_local(std::vector<int64_t> & _return, const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  send_get_neighbors_atype_local(shardId, nodeId, atype);
  recv_get_neighbors_atype_local(_return);
}

void GraphQueryAggregatorServiceClient::send_get_neighbors_atype_local(const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_neighbors_atype_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_atype_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_neighbors_atype_local(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_neighbors_atype_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_neighbors_atype_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_atype_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_neighbors_attr(std::vector<int64_t> & _return, const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  send_get_neighbors_attr(nodeId, attrId, attrKey);
  recv_get_neighbors_attr(_return);
}

void GraphQueryAggregatorServiceClient::send_get_neighbors_attr(const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_neighbors_attr", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_attr_pargs args;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_neighbors_attr(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_neighbors_attr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_neighbors_attr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_attr failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_neighbors_attr_local(std::vector<int64_t> & _return, const int32_t shardId, const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  send_get_neighbors_attr_local(shardId, nodeId, attrId, attrKey);
  recv_get_neighbors_attr_local(_return);
}

void GraphQueryAggregatorServiceClient::send_get_neighbors_attr_local(const int32_t shardId, const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_neighbors_attr_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_attr_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_neighbors_attr_local(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_neighbors_attr_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_neighbors_attr_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_attr_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_nodes(std::set<int64_t> & _return, const int32_t attrId, const std::string& attrKey)
{
  send_get_nodes(attrId, attrKey);
  recv_get_nodes(_return);
}

void GraphQueryAggregatorServiceClient::send_get_nodes(const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_nodes", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes_pargs args;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_nodes(std::set<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_nodes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_nodes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_nodes_local(std::set<int64_t> & _return, const int32_t attrId, const std::string& attrKey)
{
  send_get_nodes_local(attrId, attrKey);
  recv_get_nodes_local(_return);
}

void GraphQueryAggregatorServiceClient::send_get_nodes_local(const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_nodes_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes_local_pargs args;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_nodes_local(std::set<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_nodes_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_nodes_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_nodes2(std::set<int64_t> & _return, const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  send_get_nodes2(attrId1, attrKey1, attrId2, attrKey2);
  recv_get_nodes2(_return);
}

void GraphQueryAggregatorServiceClient::send_get_nodes2(const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_nodes2", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes2_pargs args;
  args.attrId1 = &attrId1;
  args.attrKey1 = &attrKey1;
  args.attrId2 = &attrId2;
  args.attrKey2 = &attrKey2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_nodes2(std::set<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_nodes2") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_nodes2_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes2 failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_nodes2_local(std::set<int64_t> & _return, const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  send_get_nodes2_local(attrId1, attrKey1, attrId2, attrKey2);
  recv_get_nodes2_local(_return);
}

void GraphQueryAggregatorServiceClient::send_get_nodes2_local(const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_nodes2_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes2_local_pargs args;
  args.attrId1 = &attrId1;
  args.attrKey1 = &attrKey1;
  args.attrId2 = &attrId2;
  args.attrKey2 = &attrKey2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_nodes2_local(std::set<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_nodes2_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_nodes2_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes2_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::filter_nodes_local(std::vector<int64_t> & _return, const std::vector<int64_t> & nodeIds, const int32_t attrId, const std::string& attrKey)
{
  send_filter_nodes_local(nodeIds, attrId, attrKey);
  recv_filter_nodes_local(_return);
}

void GraphQueryAggregatorServiceClient::send_filter_nodes_local(const std::vector<int64_t> & nodeIds, const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("filter_nodes_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_filter_nodes_local_pargs args;
  args.nodeIds = &nodeIds;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_filter_nodes_local(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("filter_nodes_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_filter_nodes_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "filter_nodes_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_edge_attrs(std::vector<std::string> & _return, const int64_t nodeId, const int64_t atype)
{
  send_get_edge_attrs(nodeId, atype);
  recv_get_edge_attrs(_return);
}

void GraphQueryAggregatorServiceClient::send_get_edge_attrs(const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_edge_attrs", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_edge_attrs_pargs args;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_edge_attrs(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_edge_attrs") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_edge_attrs_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_edge_attrs failed: unknown result");
}

void GraphQueryAggregatorServiceClient::get_edge_attrs_local(std::vector<std::string> & _return, const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  send_get_edge_attrs_local(shardId, nodeId, atype);
  recv_get_edge_attrs_local(_return);
}

void GraphQueryAggregatorServiceClient::send_get_edge_attrs_local(const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_edge_attrs_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_edge_attrs_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_get_edge_attrs_local(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_edge_attrs_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_get_edge_attrs_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_edge_attrs_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_range(std::vector<ThriftAssoc> & _return, const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  send_assoc_range(src, atype, off, len);
  recv_assoc_range(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_range(const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_range", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_range_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.off = &off;
  args.len = &len;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_range(std::vector<ThriftAssoc> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_range") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_range_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_range failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_range_batched(std::vector<std::vector<ThriftAssoc> > & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int32_t> & off, const std::vector<int32_t> & len)
{
  send_assoc_range_batched(src, atype, off, len);
  recv_assoc_range_batched(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_range_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int32_t> & off, const std::vector<int32_t> & len)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_range_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_range_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.off = &off;
  args.len = &len;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_range_batched(std::vector<std::vector<ThriftAssoc> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_range_batched") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_range_batched_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_range_batched failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_range_local(std::vector<ThriftAssoc> & _return, const int32_t shardId, const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  send_assoc_range_local(shardId, src, atype, off, len);
  recv_assoc_range_local(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_range_local(const int32_t shardId, const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_range_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_range_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.off = &off;
  args.len = &len;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_range_local(std::vector<ThriftAssoc> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_range_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_range_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_range_local failed: unknown result");
}

int64_t GraphQueryAggregatorServiceClient::assoc_count(const int64_t src, const int64_t atype)
{
  send_assoc_count(src, atype);
  return recv_assoc_count();
}

void GraphQueryAggregatorServiceClient::send_assoc_count(const int64_t src, const int64_t atype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_count", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_count_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t GraphQueryAggregatorServiceClient::recv_assoc_count()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_count") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  GraphQueryAggregatorService_assoc_count_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_count failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_count_batched(std::vector<int64_t> & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype)
{
  send_assoc_count_batched(src, atype);
  recv_assoc_count_batched(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_count_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_count_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_count_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_count_batched(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_count_batched") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_count_batched_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_count_batched failed: unknown result");
}

int64_t GraphQueryAggregatorServiceClient::assoc_count_local(const int32_t shardId, const int64_t src, const int64_t atype)
{
  send_assoc_count_local(shardId, src, atype);
  return recv_assoc_count_local();
}

void GraphQueryAggregatorServiceClient::send_assoc_count_local(const int32_t shardId, const int64_t src, const int64_t atype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_count_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_count_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t GraphQueryAggregatorServiceClient::recv_assoc_count_local()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_count_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  GraphQueryAggregatorService_assoc_count_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_count_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_get(std::vector<ThriftAssoc> & _return, const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  send_assoc_get(src, atype, dstIdSet, tLow, tHigh);
  recv_assoc_get(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_get(const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_get", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_get_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.dstIdSet = &dstIdSet;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_get(std::vector<ThriftAssoc> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_get") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_get_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_get failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_get_batched(std::vector<std::vector<ThriftAssoc> > & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<std::set<int64_t> > & dstIdSet, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh)
{
  send_assoc_get_batched(src, atype, dstIdSet, tLow, tHigh);
  recv_assoc_get_batched(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_get_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<std::set<int64_t> > & dstIdSet, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_get_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_get_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.dstIdSet = &dstIdSet;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_get_batched(std::vector<std::vector<ThriftAssoc> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_get_batched") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_get_batched_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_get_batched failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_get_local(std::vector<ThriftAssoc> & _return, const int32_t shardId, const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  send_assoc_get_local(shardId, src, atype, dstIdSet, tLow, tHigh);
  recv_assoc_get_local(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_get_local(const int32_t shardId, const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_get_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_get_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.dstIdSet = &dstIdSet;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_get_local(std::vector<ThriftAssoc> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_get_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_get_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_get_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::obj_get(std::vector<std::string> & _return, const int64_t nodeId)
{
  send_obj_get(nodeId);
  recv_obj_get(_return);
}

void GraphQueryAggregatorServiceClient::send_obj_get(const int64_t nodeId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("obj_get", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_obj_get_pargs args;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_obj_get(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("obj_get") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_obj_get_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "obj_get failed: unknown result");
}

void GraphQueryAggregatorServiceClient::obj_get_batched(std::vector<std::vector<std::string> > & _return, const std::vector<int64_t> & nodeId)
{
  send_obj_get_batched(nodeId);
  recv_obj_get_batched(_return);
}

void GraphQueryAggregatorServiceClient::send_obj_get_batched(const std::vector<int64_t> & nodeId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("obj_get_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_obj_get_batched_pargs args;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_obj_get_batched(std::vector<std::vector<std::string> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("obj_get_batched") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_obj_get_batched_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "obj_get_batched failed: unknown result");
}

void GraphQueryAggregatorServiceClient::obj_get_local(std::vector<std::string> & _return, const int32_t shardId, const int64_t nodeId)
{
  send_obj_get_local(shardId, nodeId);
  recv_obj_get_local(_return);
}

void GraphQueryAggregatorServiceClient::send_obj_get_local(const int32_t shardId, const int64_t nodeId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("obj_get_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_obj_get_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_obj_get_local(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("obj_get_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_obj_get_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "obj_get_local failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_time_range(std::vector<ThriftAssoc> & _return, const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  send_assoc_time_range(src, atype, tLow, tHigh, limit);
  recv_assoc_time_range(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_time_range(const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_time_range", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_time_range_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.limit = &limit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_time_range(std::vector<ThriftAssoc> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_time_range") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_time_range_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_time_range failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_time_range_batched(std::vector<std::vector<ThriftAssoc> > & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh, const std::vector<int32_t> & limit)
{
  send_assoc_time_range_batched(src, atype, tLow, tHigh, limit);
  recv_assoc_time_range_batched(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_time_range_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh, const std::vector<int32_t> & limit)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_time_range_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_time_range_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.limit = &limit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_time_range_batched(std::vector<std::vector<ThriftAssoc> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_time_range_batched") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_time_range_batched_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_time_range_batched failed: unknown result");
}

void GraphQueryAggregatorServiceClient::assoc_time_range_local(std::vector<ThriftAssoc> & _return, const int32_t shardId, const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  send_assoc_time_range_local(shardId, src, atype, tLow, tHigh, limit);
  recv_assoc_time_range_local(_return);
}

void GraphQueryAggregatorServiceClient::send_assoc_time_range_local(const int32_t shardId, const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_time_range_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_time_range_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.limit = &limit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void GraphQueryAggregatorServiceClient::recv_assoc_time_range_local(std::vector<ThriftAssoc> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_time_range_local") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  GraphQueryAggregatorService_assoc_time_range_local_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_time_range_local failed: unknown result");
}

int32_t GraphQueryAggregatorServiceClient::assoc_add(const int64_t src, const int64_t atype, const int64_t dst, const int64_t time, const std::string& attr)
{
  send_assoc_add(src, atype, dst, time, attr);
  return recv_assoc_add();
}

void GraphQueryAggregatorServiceClient::send_assoc_add(const int64_t src, const int64_t atype, const int64_t dst, const int64_t time, const std::string& attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("assoc_add", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_add_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.dst = &dst;
  args.time = &time;
  args.attr = &attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t GraphQueryAggregatorServiceClient::recv_assoc_add()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("assoc_add") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  GraphQueryAggregatorService_assoc_add_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_add failed: unknown result");
}

bool GraphQueryAggregatorServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void GraphQueryAggregatorServiceProcessor::process_init(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.init", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.init");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.init");
  }

  GraphQueryAggregatorService_init_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.init", bytes);
  }

  GraphQueryAggregatorService_init_result result;
  try {
    result.success = iface_->init();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.init");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("init", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.init");
  }

  oprot->writeMessageBegin("init", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.init", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_init_local_shards(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.init_local_shards", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.init_local_shards");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.init_local_shards");
  }

  GraphQueryAggregatorService_init_local_shards_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.init_local_shards", bytes);
  }

  GraphQueryAggregatorService_init_local_shards_result result;
  try {
    result.success = iface_->init_local_shards();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.init_local_shards");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("init_local_shards", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.init_local_shards");
  }

  oprot->writeMessageBegin("init_local_shards", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.init_local_shards", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_local_data_init(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.local_data_init", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.local_data_init");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.local_data_init");
  }

  GraphQueryAggregatorService_local_data_init_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.local_data_init", bytes);
  }

  GraphQueryAggregatorService_local_data_init_result result;
  try {
    result.success = iface_->local_data_init();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.local_data_init");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("local_data_init", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.local_data_init");
  }

  oprot->writeMessageBegin("local_data_init", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.local_data_init", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_connect_to_aggregators(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.connect_to_aggregators", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.connect_to_aggregators");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.connect_to_aggregators");
  }

  GraphQueryAggregatorService_connect_to_aggregators_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.connect_to_aggregators", bytes);
  }

  GraphQueryAggregatorService_connect_to_aggregators_result result;
  try {
    result.success = iface_->connect_to_aggregators();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.connect_to_aggregators");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("connect_to_aggregators", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.connect_to_aggregators");
  }

  oprot->writeMessageBegin("connect_to_aggregators", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.connect_to_aggregators", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_connect_to_local_shards(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.connect_to_local_shards", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.connect_to_local_shards");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.connect_to_local_shards");
  }

  GraphQueryAggregatorService_connect_to_local_shards_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.connect_to_local_shards", bytes);
  }

  GraphQueryAggregatorService_connect_to_local_shards_result result;
  try {
    result.success = iface_->connect_to_local_shards();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.connect_to_local_shards");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("connect_to_local_shards", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.connect_to_local_shards");
  }

  oprot->writeMessageBegin("connect_to_local_shards", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.connect_to_local_shards", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_shutdown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.shutdown", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.shutdown");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.shutdown");
  }

  GraphQueryAggregatorService_shutdown_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.shutdown", bytes);
  }

  GraphQueryAggregatorService_shutdown_result result;
  try {
    iface_->shutdown();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.shutdown");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("shutdown", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.shutdown");
  }

  oprot->writeMessageBegin("shutdown", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.shutdown", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_disconnect_from_local_shards(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.disconnect_from_local_shards", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.disconnect_from_local_shards");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.disconnect_from_local_shards");
  }

  GraphQueryAggregatorService_disconnect_from_local_shards_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.disconnect_from_local_shards", bytes);
  }

  GraphQueryAggregatorService_disconnect_from_local_shards_result result;
  try {
    iface_->disconnect_from_local_shards();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.disconnect_from_local_shards");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("disconnect_from_local_shards", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.disconnect_from_local_shards");
  }

  oprot->writeMessageBegin("disconnect_from_local_shards", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.disconnect_from_local_shards", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_disconnect_from_aggregators(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.disconnect_from_aggregators", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.disconnect_from_aggregators");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.disconnect_from_aggregators");
  }

  GraphQueryAggregatorService_disconnect_from_aggregators_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.disconnect_from_aggregators", bytes);
  }

  GraphQueryAggregatorService_disconnect_from_aggregators_result result;
  try {
    iface_->disconnect_from_aggregators();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.disconnect_from_aggregators");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("disconnect_from_aggregators", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.disconnect_from_aggregators");
  }

  oprot->writeMessageBegin("disconnect_from_aggregators", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.disconnect_from_aggregators", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_backfill_edge_updates(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.backfill_edge_updates", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.backfill_edge_updates");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.backfill_edge_updates");
  }

  GraphQueryAggregatorService_backfill_edge_updates_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.backfill_edge_updates", bytes);
  }

  GraphQueryAggregatorService_backfill_edge_updates_result result;
  try {
    result.success = iface_->backfill_edge_updates();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.backfill_edge_updates");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("backfill_edge_updates", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.backfill_edge_updates");
  }

  oprot->writeMessageBegin("backfill_edge_updates", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.backfill_edge_updates", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_record_edge_updates(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.record_edge_updates", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.record_edge_updates");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.record_edge_updates");
  }

  GraphQueryAggregatorService_record_edge_updates_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.record_edge_updates", bytes);
  }

  GraphQueryAggregatorService_record_edge_updates_result result;
  try {
    iface_->record_edge_updates(args.next_shard, args.local_shard, args.updates);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.record_edge_updates");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("record_edge_updates", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.record_edge_updates");
  }

  oprot->writeMessageBegin("record_edge_updates", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.record_edge_updates", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_attribute");
  }

  GraphQueryAggregatorService_get_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_attribute", bytes);
  }

  GraphQueryAggregatorService_get_attribute_result result;
  try {
    iface_->get_attribute(result.success, args.nodeId, args.attrId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_attribute");
  }

  oprot->writeMessageBegin("get_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_attribute", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_attribute_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_attribute_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_attribute_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_attribute_local");
  }

  GraphQueryAggregatorService_get_attribute_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_attribute_local", bytes);
  }

  GraphQueryAggregatorService_get_attribute_local_result result;
  try {
    iface_->get_attribute_local(result.success, args.shardId, args.nodeId, args.attrId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_attribute_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_attribute_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_attribute_local");
  }

  oprot->writeMessageBegin("get_attribute_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_attribute_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_neighbors(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_neighbors", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_neighbors");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_neighbors");
  }

  GraphQueryAggregatorService_get_neighbors_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_neighbors", bytes);
  }

  GraphQueryAggregatorService_get_neighbors_result result;
  try {
    iface_->get_neighbors(result.success, args.nodeId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_neighbors");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_neighbors", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_neighbors");
  }

  oprot->writeMessageBegin("get_neighbors", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_neighbors", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_neighbors_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_neighbors_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_neighbors_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_neighbors_local");
  }

  GraphQueryAggregatorService_get_neighbors_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_neighbors_local", bytes);
  }

  GraphQueryAggregatorService_get_neighbors_local_result result;
  try {
    iface_->get_neighbors_local(result.success, args.shardId, args.nodeId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_neighbors_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_neighbors_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_neighbors_local");
  }

  oprot->writeMessageBegin("get_neighbors_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_neighbors_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_neighbors_atype(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_neighbors_atype", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_neighbors_atype");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_neighbors_atype");
  }

  GraphQueryAggregatorService_get_neighbors_atype_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_neighbors_atype", bytes);
  }

  GraphQueryAggregatorService_get_neighbors_atype_result result;
  try {
    iface_->get_neighbors_atype(result.success, args.nodeId, args.atype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_neighbors_atype");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_neighbors_atype", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_neighbors_atype");
  }

  oprot->writeMessageBegin("get_neighbors_atype", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_neighbors_atype", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_neighbors_atype_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_neighbors_atype_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_neighbors_atype_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_neighbors_atype_local");
  }

  GraphQueryAggregatorService_get_neighbors_atype_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_neighbors_atype_local", bytes);
  }

  GraphQueryAggregatorService_get_neighbors_atype_local_result result;
  try {
    iface_->get_neighbors_atype_local(result.success, args.shardId, args.nodeId, args.atype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_neighbors_atype_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_neighbors_atype_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_neighbors_atype_local");
  }

  oprot->writeMessageBegin("get_neighbors_atype_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_neighbors_atype_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_neighbors_attr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_neighbors_attr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_neighbors_attr");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_neighbors_attr");
  }

  GraphQueryAggregatorService_get_neighbors_attr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_neighbors_attr", bytes);
  }

  GraphQueryAggregatorService_get_neighbors_attr_result result;
  try {
    iface_->get_neighbors_attr(result.success, args.nodeId, args.attrId, args.attrKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_neighbors_attr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_neighbors_attr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_neighbors_attr");
  }

  oprot->writeMessageBegin("get_neighbors_attr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_neighbors_attr", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_neighbors_attr_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_neighbors_attr_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_neighbors_attr_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_neighbors_attr_local");
  }

  GraphQueryAggregatorService_get_neighbors_attr_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_neighbors_attr_local", bytes);
  }

  GraphQueryAggregatorService_get_neighbors_attr_local_result result;
  try {
    iface_->get_neighbors_attr_local(result.success, args.shardId, args.nodeId, args.attrId, args.attrKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_neighbors_attr_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_neighbors_attr_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_neighbors_attr_local");
  }

  oprot->writeMessageBegin("get_neighbors_attr_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_neighbors_attr_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_nodes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_nodes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_nodes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_nodes");
  }

  GraphQueryAggregatorService_get_nodes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_nodes", bytes);
  }

  GraphQueryAggregatorService_get_nodes_result result;
  try {
    iface_->get_nodes(result.success, args.attrId, args.attrKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_nodes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_nodes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_nodes");
  }

  oprot->writeMessageBegin("get_nodes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_nodes", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_nodes_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_nodes_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_nodes_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_nodes_local");
  }

  GraphQueryAggregatorService_get_nodes_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_nodes_local", bytes);
  }

  GraphQueryAggregatorService_get_nodes_local_result result;
  try {
    iface_->get_nodes_local(result.success, args.attrId, args.attrKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_nodes_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_nodes_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_nodes_local");
  }

  oprot->writeMessageBegin("get_nodes_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_nodes_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_nodes2(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_nodes2", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_nodes2");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_nodes2");
  }

  GraphQueryAggregatorService_get_nodes2_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_nodes2", bytes);
  }

  GraphQueryAggregatorService_get_nodes2_result result;
  try {
    iface_->get_nodes2(result.success, args.attrId1, args.attrKey1, args.attrId2, args.attrKey2);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_nodes2");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_nodes2", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_nodes2");
  }

  oprot->writeMessageBegin("get_nodes2", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_nodes2", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_nodes2_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_nodes2_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_nodes2_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_nodes2_local");
  }

  GraphQueryAggregatorService_get_nodes2_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_nodes2_local", bytes);
  }

  GraphQueryAggregatorService_get_nodes2_local_result result;
  try {
    iface_->get_nodes2_local(result.success, args.attrId1, args.attrKey1, args.attrId2, args.attrKey2);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_nodes2_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_nodes2_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_nodes2_local");
  }

  oprot->writeMessageBegin("get_nodes2_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_nodes2_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_filter_nodes_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.filter_nodes_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.filter_nodes_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.filter_nodes_local");
  }

  GraphQueryAggregatorService_filter_nodes_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.filter_nodes_local", bytes);
  }

  GraphQueryAggregatorService_filter_nodes_local_result result;
  try {
    iface_->filter_nodes_local(result.success, args.nodeIds, args.attrId, args.attrKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.filter_nodes_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("filter_nodes_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.filter_nodes_local");
  }

  oprot->writeMessageBegin("filter_nodes_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.filter_nodes_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_edge_attrs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_edge_attrs", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_edge_attrs");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_edge_attrs");
  }

  GraphQueryAggregatorService_get_edge_attrs_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_edge_attrs", bytes);
  }

  GraphQueryAggregatorService_get_edge_attrs_result result;
  try {
    iface_->get_edge_attrs(result.success, args.nodeId, args.atype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_edge_attrs");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_edge_attrs", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_edge_attrs");
  }

  oprot->writeMessageBegin("get_edge_attrs", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_edge_attrs", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_get_edge_attrs_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.get_edge_attrs_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.get_edge_attrs_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.get_edge_attrs_local");
  }

  GraphQueryAggregatorService_get_edge_attrs_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.get_edge_attrs_local", bytes);
  }

  GraphQueryAggregatorService_get_edge_attrs_local_result result;
  try {
    iface_->get_edge_attrs_local(result.success, args.shardId, args.nodeId, args.atype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.get_edge_attrs_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_edge_attrs_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.get_edge_attrs_local");
  }

  oprot->writeMessageBegin("get_edge_attrs_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.get_edge_attrs_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_range(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_range", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_range");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_range");
  }

  GraphQueryAggregatorService_assoc_range_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_range", bytes);
  }

  GraphQueryAggregatorService_assoc_range_result result;
  try {
    iface_->assoc_range(result.success, args.src, args.atype, args.off, args.len);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_range");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_range", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_range");
  }

  oprot->writeMessageBegin("assoc_range", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_range", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_range_batched(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_range_batched", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_range_batched");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_range_batched");
  }

  GraphQueryAggregatorService_assoc_range_batched_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_range_batched", bytes);
  }

  GraphQueryAggregatorService_assoc_range_batched_result result;
  try {
    iface_->assoc_range_batched(result.success, args.src, args.atype, args.off, args.len);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_range_batched");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_range_batched", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_range_batched");
  }

  oprot->writeMessageBegin("assoc_range_batched", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_range_batched", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_range_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_range_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_range_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_range_local");
  }

  GraphQueryAggregatorService_assoc_range_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_range_local", bytes);
  }

  GraphQueryAggregatorService_assoc_range_local_result result;
  try {
    iface_->assoc_range_local(result.success, args.shardId, args.src, args.atype, args.off, args.len);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_range_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_range_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_range_local");
  }

  oprot->writeMessageBegin("assoc_range_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_range_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_count(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_count", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_count");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_count");
  }

  GraphQueryAggregatorService_assoc_count_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_count", bytes);
  }

  GraphQueryAggregatorService_assoc_count_result result;
  try {
    result.success = iface_->assoc_count(args.src, args.atype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_count");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_count", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_count");
  }

  oprot->writeMessageBegin("assoc_count", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_count", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_count_batched(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_count_batched", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_count_batched");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_count_batched");
  }

  GraphQueryAggregatorService_assoc_count_batched_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_count_batched", bytes);
  }

  GraphQueryAggregatorService_assoc_count_batched_result result;
  try {
    iface_->assoc_count_batched(result.success, args.src, args.atype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_count_batched");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_count_batched", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_count_batched");
  }

  oprot->writeMessageBegin("assoc_count_batched", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_count_batched", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_count_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_count_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_count_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_count_local");
  }

  GraphQueryAggregatorService_assoc_count_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_count_local", bytes);
  }

  GraphQueryAggregatorService_assoc_count_local_result result;
  try {
    result.success = iface_->assoc_count_local(args.shardId, args.src, args.atype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_count_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_count_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_count_local");
  }

  oprot->writeMessageBegin("assoc_count_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_count_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_get", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_get");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_get");
  }

  GraphQueryAggregatorService_assoc_get_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_get", bytes);
  }

  GraphQueryAggregatorService_assoc_get_result result;
  try {
    iface_->assoc_get(result.success, args.src, args.atype, args.dstIdSet, args.tLow, args.tHigh);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_get");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_get", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_get");
  }

  oprot->writeMessageBegin("assoc_get", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_get", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_get_batched(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_get_batched", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_get_batched");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_get_batched");
  }

  GraphQueryAggregatorService_assoc_get_batched_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_get_batched", bytes);
  }

  GraphQueryAggregatorService_assoc_get_batched_result result;
  try {
    iface_->assoc_get_batched(result.success, args.src, args.atype, args.dstIdSet, args.tLow, args.tHigh);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_get_batched");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_get_batched", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_get_batched");
  }

  oprot->writeMessageBegin("assoc_get_batched", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_get_batched", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_get_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_get_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_get_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_get_local");
  }

  GraphQueryAggregatorService_assoc_get_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_get_local", bytes);
  }

  GraphQueryAggregatorService_assoc_get_local_result result;
  try {
    iface_->assoc_get_local(result.success, args.shardId, args.src, args.atype, args.dstIdSet, args.tLow, args.tHigh);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_get_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_get_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_get_local");
  }

  oprot->writeMessageBegin("assoc_get_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_get_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_obj_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.obj_get", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.obj_get");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.obj_get");
  }

  GraphQueryAggregatorService_obj_get_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.obj_get", bytes);
  }

  GraphQueryAggregatorService_obj_get_result result;
  try {
    iface_->obj_get(result.success, args.nodeId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.obj_get");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("obj_get", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.obj_get");
  }

  oprot->writeMessageBegin("obj_get", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.obj_get", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_obj_get_batched(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.obj_get_batched", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.obj_get_batched");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.obj_get_batched");
  }

  GraphQueryAggregatorService_obj_get_batched_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.obj_get_batched", bytes);
  }

  GraphQueryAggregatorService_obj_get_batched_result result;
  try {
    iface_->obj_get_batched(result.success, args.nodeId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.obj_get_batched");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("obj_get_batched", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.obj_get_batched");
  }

  oprot->writeMessageBegin("obj_get_batched", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.obj_get_batched", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_obj_get_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.obj_get_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.obj_get_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.obj_get_local");
  }

  GraphQueryAggregatorService_obj_get_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.obj_get_local", bytes);
  }

  GraphQueryAggregatorService_obj_get_local_result result;
  try {
    iface_->obj_get_local(result.success, args.shardId, args.nodeId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.obj_get_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("obj_get_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.obj_get_local");
  }

  oprot->writeMessageBegin("obj_get_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.obj_get_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_time_range(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_time_range", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_time_range");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_time_range");
  }

  GraphQueryAggregatorService_assoc_time_range_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_time_range", bytes);
  }

  GraphQueryAggregatorService_assoc_time_range_result result;
  try {
    iface_->assoc_time_range(result.success, args.src, args.atype, args.tLow, args.tHigh, args.limit);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_time_range");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_time_range", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_time_range");
  }

  oprot->writeMessageBegin("assoc_time_range", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_time_range", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_time_range_batched(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_time_range_batched", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_time_range_batched");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_time_range_batched");
  }

  GraphQueryAggregatorService_assoc_time_range_batched_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_time_range_batched", bytes);
  }

  GraphQueryAggregatorService_assoc_time_range_batched_result result;
  try {
    iface_->assoc_time_range_batched(result.success, args.src, args.atype, args.tLow, args.tHigh, args.limit);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_time_range_batched");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_time_range_batched", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_time_range_batched");
  }

  oprot->writeMessageBegin("assoc_time_range_batched", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_time_range_batched", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_time_range_local(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_time_range_local", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_time_range_local");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_time_range_local");
  }

  GraphQueryAggregatorService_assoc_time_range_local_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_time_range_local", bytes);
  }

  GraphQueryAggregatorService_assoc_time_range_local_result result;
  try {
    iface_->assoc_time_range_local(result.success, args.shardId, args.src, args.atype, args.tLow, args.tHigh, args.limit);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_time_range_local");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_time_range_local", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_time_range_local");
  }

  oprot->writeMessageBegin("assoc_time_range_local", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_time_range_local", bytes);
  }
}

void GraphQueryAggregatorServiceProcessor::process_assoc_add(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("GraphQueryAggregatorService.assoc_add", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "GraphQueryAggregatorService.assoc_add");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "GraphQueryAggregatorService.assoc_add");
  }

  GraphQueryAggregatorService_assoc_add_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "GraphQueryAggregatorService.assoc_add", bytes);
  }

  GraphQueryAggregatorService_assoc_add_result result;
  try {
    result.success = iface_->assoc_add(args.src, args.atype, args.dst, args.time, args.attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "GraphQueryAggregatorService.assoc_add");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("assoc_add", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "GraphQueryAggregatorService.assoc_add");
  }

  oprot->writeMessageBegin("assoc_add", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "GraphQueryAggregatorService.assoc_add", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > GraphQueryAggregatorServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< GraphQueryAggregatorServiceIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< GraphQueryAggregatorServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new GraphQueryAggregatorServiceProcessor(handler));
  return processor;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::init()
{
  int32_t seqid = send_init();
  return recv_init(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_init()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("init", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_init_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::recv_init(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("init") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      GraphQueryAggregatorService_init_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "init failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t GraphQueryAggregatorServiceConcurrentClient::init_local_shards()
{
  int32_t seqid = send_init_local_shards();
  return recv_init_local_shards(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_init_local_shards()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("init_local_shards", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_init_local_shards_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::recv_init_local_shards(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("init_local_shards") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      GraphQueryAggregatorService_init_local_shards_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "init_local_shards failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t GraphQueryAggregatorServiceConcurrentClient::local_data_init()
{
  int32_t seqid = send_local_data_init();
  return recv_local_data_init(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_local_data_init()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("local_data_init", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_local_data_init_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::recv_local_data_init(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("local_data_init") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      GraphQueryAggregatorService_local_data_init_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "local_data_init failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t GraphQueryAggregatorServiceConcurrentClient::connect_to_aggregators()
{
  int32_t seqid = send_connect_to_aggregators();
  return recv_connect_to_aggregators(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_connect_to_aggregators()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("connect_to_aggregators", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_connect_to_aggregators_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::recv_connect_to_aggregators(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("connect_to_aggregators") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      GraphQueryAggregatorService_connect_to_aggregators_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect_to_aggregators failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t GraphQueryAggregatorServiceConcurrentClient::connect_to_local_shards()
{
  int32_t seqid = send_connect_to_local_shards();
  return recv_connect_to_local_shards(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_connect_to_local_shards()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("connect_to_local_shards", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_connect_to_local_shards_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::recv_connect_to_local_shards(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("connect_to_local_shards") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      GraphQueryAggregatorService_connect_to_local_shards_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect_to_local_shards failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::shutdown()
{
  int32_t seqid = send_shutdown();
  recv_shutdown(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_shutdown()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("shutdown", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_shutdown_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_shutdown(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("shutdown") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_shutdown_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::disconnect_from_local_shards()
{
  int32_t seqid = send_disconnect_from_local_shards();
  recv_disconnect_from_local_shards(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_disconnect_from_local_shards()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("disconnect_from_local_shards", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_disconnect_from_local_shards_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_disconnect_from_local_shards(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("disconnect_from_local_shards") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_disconnect_from_local_shards_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::disconnect_from_aggregators()
{
  int32_t seqid = send_disconnect_from_aggregators();
  recv_disconnect_from_aggregators(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_disconnect_from_aggregators()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("disconnect_from_aggregators", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_disconnect_from_aggregators_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_disconnect_from_aggregators(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("disconnect_from_aggregators") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_disconnect_from_aggregators_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t GraphQueryAggregatorServiceConcurrentClient::backfill_edge_updates()
{
  int32_t seqid = send_backfill_edge_updates();
  return recv_backfill_edge_updates(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_backfill_edge_updates()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("backfill_edge_updates", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_backfill_edge_updates_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::recv_backfill_edge_updates(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("backfill_edge_updates") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      GraphQueryAggregatorService_backfill_edge_updates_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "backfill_edge_updates failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::record_edge_updates(const int32_t next_shard, const int32_t local_shard, const std::vector<ThriftSrcAtype> & updates)
{
  int32_t seqid = send_record_edge_updates(next_shard, local_shard, updates);
  recv_record_edge_updates(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_record_edge_updates(const int32_t next_shard, const int32_t local_shard, const std::vector<ThriftSrcAtype> & updates)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("record_edge_updates", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_record_edge_updates_pargs args;
  args.next_shard = &next_shard;
  args.local_shard = &local_shard;
  args.updates = &updates;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_record_edge_updates(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("record_edge_updates") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_record_edge_updates_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_attribute(std::string& _return, const int64_t nodeId, const int32_t attrId)
{
  int32_t seqid = send_get_attribute(nodeId, attrId);
  recv_get_attribute(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_attribute(const int64_t nodeId, const int32_t attrId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_attribute_pargs args;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_attribute(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_attribute_local(std::string& _return, const int64_t shardId, const int64_t nodeId, const int32_t attrId)
{
  int32_t seqid = send_get_attribute_local(shardId, nodeId, attrId);
  recv_get_attribute_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_attribute_local(const int64_t shardId, const int64_t nodeId, const int32_t attrId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_attribute_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_attribute_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_attribute_local(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_attribute_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_attribute_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_attribute_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_neighbors(std::vector<int64_t> & _return, const int64_t nodeId)
{
  int32_t seqid = send_get_neighbors(nodeId);
  recv_get_neighbors(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_neighbors(const int64_t nodeId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_neighbors", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_pargs args;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_neighbors(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_neighbors") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_neighbors_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_neighbors_local(std::vector<int64_t> & _return, const int32_t shardId, const int64_t nodeId)
{
  int32_t seqid = send_get_neighbors_local(shardId, nodeId);
  recv_get_neighbors_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_neighbors_local(const int32_t shardId, const int64_t nodeId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_neighbors_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_neighbors_local(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_neighbors_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_neighbors_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_neighbors_atype(std::vector<int64_t> & _return, const int64_t nodeId, const int64_t atype)
{
  int32_t seqid = send_get_neighbors_atype(nodeId, atype);
  recv_get_neighbors_atype(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_neighbors_atype(const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_neighbors_atype", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_atype_pargs args;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_neighbors_atype(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_neighbors_atype") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_neighbors_atype_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_atype failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_neighbors_atype_local(std::vector<int64_t> & _return, const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  int32_t seqid = send_get_neighbors_atype_local(shardId, nodeId, atype);
  recv_get_neighbors_atype_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_neighbors_atype_local(const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_neighbors_atype_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_atype_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_neighbors_atype_local(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_neighbors_atype_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_neighbors_atype_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_atype_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_neighbors_attr(std::vector<int64_t> & _return, const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  int32_t seqid = send_get_neighbors_attr(nodeId, attrId, attrKey);
  recv_get_neighbors_attr(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_neighbors_attr(const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_neighbors_attr", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_attr_pargs args;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_neighbors_attr(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_neighbors_attr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_neighbors_attr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_attr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_neighbors_attr_local(std::vector<int64_t> & _return, const int32_t shardId, const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  int32_t seqid = send_get_neighbors_attr_local(shardId, nodeId, attrId, attrKey);
  recv_get_neighbors_attr_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_neighbors_attr_local(const int32_t shardId, const int64_t nodeId, const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_neighbors_attr_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_neighbors_attr_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_neighbors_attr_local(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_neighbors_attr_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_neighbors_attr_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_neighbors_attr_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_nodes(std::set<int64_t> & _return, const int32_t attrId, const std::string& attrKey)
{
  int32_t seqid = send_get_nodes(attrId, attrKey);
  recv_get_nodes(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_nodes(const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_nodes", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes_pargs args;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_nodes(std::set<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_nodes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_nodes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_nodes_local(std::set<int64_t> & _return, const int32_t attrId, const std::string& attrKey)
{
  int32_t seqid = send_get_nodes_local(attrId, attrKey);
  recv_get_nodes_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_nodes_local(const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_nodes_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes_local_pargs args;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_nodes_local(std::set<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_nodes_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_nodes_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_nodes2(std::set<int64_t> & _return, const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  int32_t seqid = send_get_nodes2(attrId1, attrKey1, attrId2, attrKey2);
  recv_get_nodes2(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_nodes2(const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_nodes2", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes2_pargs args;
  args.attrId1 = &attrId1;
  args.attrKey1 = &attrKey1;
  args.attrId2 = &attrId2;
  args.attrKey2 = &attrKey2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_nodes2(std::set<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_nodes2") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_nodes2_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes2 failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_nodes2_local(std::set<int64_t> & _return, const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  int32_t seqid = send_get_nodes2_local(attrId1, attrKey1, attrId2, attrKey2);
  recv_get_nodes2_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_nodes2_local(const int32_t attrId1, const std::string& attrKey1, const int32_t attrId2, const std::string& attrKey2)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_nodes2_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_nodes2_local_pargs args;
  args.attrId1 = &attrId1;
  args.attrKey1 = &attrKey1;
  args.attrId2 = &attrId2;
  args.attrKey2 = &attrKey2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_nodes2_local(std::set<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_nodes2_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_nodes2_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_nodes2_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::filter_nodes_local(std::vector<int64_t> & _return, const std::vector<int64_t> & nodeIds, const int32_t attrId, const std::string& attrKey)
{
  int32_t seqid = send_filter_nodes_local(nodeIds, attrId, attrKey);
  recv_filter_nodes_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_filter_nodes_local(const std::vector<int64_t> & nodeIds, const int32_t attrId, const std::string& attrKey)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("filter_nodes_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_filter_nodes_local_pargs args;
  args.nodeIds = &nodeIds;
  args.attrId = &attrId;
  args.attrKey = &attrKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_filter_nodes_local(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("filter_nodes_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_filter_nodes_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "filter_nodes_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_edge_attrs(std::vector<std::string> & _return, const int64_t nodeId, const int64_t atype)
{
  int32_t seqid = send_get_edge_attrs(nodeId, atype);
  recv_get_edge_attrs(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_edge_attrs(const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_edge_attrs", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_edge_attrs_pargs args;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_edge_attrs(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_edge_attrs") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_edge_attrs_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_edge_attrs failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::get_edge_attrs_local(std::vector<std::string> & _return, const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  int32_t seqid = send_get_edge_attrs_local(shardId, nodeId, atype);
  recv_get_edge_attrs_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_get_edge_attrs_local(const int32_t shardId, const int64_t nodeId, const int64_t atype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_edge_attrs_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_get_edge_attrs_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_get_edge_attrs_local(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_edge_attrs_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_get_edge_attrs_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_edge_attrs_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_range(std::vector<ThriftAssoc> & _return, const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  int32_t seqid = send_assoc_range(src, atype, off, len);
  recv_assoc_range(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_range(const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_range", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_range_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.off = &off;
  args.len = &len;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_range(std::vector<ThriftAssoc> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_range") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_range_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_range failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_range_batched(std::vector<std::vector<ThriftAssoc> > & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int32_t> & off, const std::vector<int32_t> & len)
{
  int32_t seqid = send_assoc_range_batched(src, atype, off, len);
  recv_assoc_range_batched(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_range_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int32_t> & off, const std::vector<int32_t> & len)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_range_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_range_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.off = &off;
  args.len = &len;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_range_batched(std::vector<std::vector<ThriftAssoc> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_range_batched") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_range_batched_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_range_batched failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_range_local(std::vector<ThriftAssoc> & _return, const int32_t shardId, const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  int32_t seqid = send_assoc_range_local(shardId, src, atype, off, len);
  recv_assoc_range_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_range_local(const int32_t shardId, const int64_t src, const int64_t atype, const int32_t off, const int32_t len)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_range_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_range_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.off = &off;
  args.len = &len;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_range_local(std::vector<ThriftAssoc> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_range_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_range_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_range_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t GraphQueryAggregatorServiceConcurrentClient::assoc_count(const int64_t src, const int64_t atype)
{
  int32_t seqid = send_assoc_count(src, atype);
  return recv_assoc_count(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_count(const int64_t src, const int64_t atype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_count", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_count_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t GraphQueryAggregatorServiceConcurrentClient::recv_assoc_count(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_count") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      GraphQueryAggregatorService_assoc_count_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_count failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_count_batched(std::vector<int64_t> & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype)
{
  int32_t seqid = send_assoc_count_batched(src, atype);
  recv_assoc_count_batched(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_count_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_count_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_count_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_count_batched(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_count_batched") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_count_batched_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_count_batched failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t GraphQueryAggregatorServiceConcurrentClient::assoc_count_local(const int32_t shardId, const int64_t src, const int64_t atype)
{
  int32_t seqid = send_assoc_count_local(shardId, src, atype);
  return recv_assoc_count_local(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_count_local(const int32_t shardId, const int64_t src, const int64_t atype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_count_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_count_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t GraphQueryAggregatorServiceConcurrentClient::recv_assoc_count_local(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_count_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      GraphQueryAggregatorService_assoc_count_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_count_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_get(std::vector<ThriftAssoc> & _return, const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  int32_t seqid = send_assoc_get(src, atype, dstIdSet, tLow, tHigh);
  recv_assoc_get(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_get(const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_get", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_get_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.dstIdSet = &dstIdSet;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_get(std::vector<ThriftAssoc> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_get") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_get_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_get failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_get_batched(std::vector<std::vector<ThriftAssoc> > & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<std::set<int64_t> > & dstIdSet, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh)
{
  int32_t seqid = send_assoc_get_batched(src, atype, dstIdSet, tLow, tHigh);
  recv_assoc_get_batched(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_get_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<std::set<int64_t> > & dstIdSet, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_get_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_get_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.dstIdSet = &dstIdSet;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_get_batched(std::vector<std::vector<ThriftAssoc> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_get_batched") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_get_batched_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_get_batched failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_get_local(std::vector<ThriftAssoc> & _return, const int32_t shardId, const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  int32_t seqid = send_assoc_get_local(shardId, src, atype, dstIdSet, tLow, tHigh);
  recv_assoc_get_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_get_local(const int32_t shardId, const int64_t src, const int64_t atype, const std::set<int64_t> & dstIdSet, const int64_t tLow, const int64_t tHigh)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_get_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_get_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.dstIdSet = &dstIdSet;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_get_local(std::vector<ThriftAssoc> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_get_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_get_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_get_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::obj_get(std::vector<std::string> & _return, const int64_t nodeId)
{
  int32_t seqid = send_obj_get(nodeId);
  recv_obj_get(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_obj_get(const int64_t nodeId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("obj_get", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_obj_get_pargs args;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_obj_get(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("obj_get") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_obj_get_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "obj_get failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::obj_get_batched(std::vector<std::vector<std::string> > & _return, const std::vector<int64_t> & nodeId)
{
  int32_t seqid = send_obj_get_batched(nodeId);
  recv_obj_get_batched(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_obj_get_batched(const std::vector<int64_t> & nodeId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("obj_get_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_obj_get_batched_pargs args;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_obj_get_batched(std::vector<std::vector<std::string> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("obj_get_batched") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_obj_get_batched_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "obj_get_batched failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::obj_get_local(std::vector<std::string> & _return, const int32_t shardId, const int64_t nodeId)
{
  int32_t seqid = send_obj_get_local(shardId, nodeId);
  recv_obj_get_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_obj_get_local(const int32_t shardId, const int64_t nodeId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("obj_get_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_obj_get_local_pargs args;
  args.shardId = &shardId;
  args.nodeId = &nodeId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_obj_get_local(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("obj_get_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_obj_get_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "obj_get_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_time_range(std::vector<ThriftAssoc> & _return, const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  int32_t seqid = send_assoc_time_range(src, atype, tLow, tHigh, limit);
  recv_assoc_time_range(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_time_range(const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_time_range", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_time_range_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.limit = &limit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_time_range(std::vector<ThriftAssoc> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_time_range") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_time_range_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_time_range failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_time_range_batched(std::vector<std::vector<ThriftAssoc> > & _return, const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh, const std::vector<int32_t> & limit)
{
  int32_t seqid = send_assoc_time_range_batched(src, atype, tLow, tHigh, limit);
  recv_assoc_time_range_batched(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_time_range_batched(const std::vector<int64_t> & src, const std::vector<int64_t> & atype, const std::vector<int64_t> & tLow, const std::vector<int64_t> & tHigh, const std::vector<int32_t> & limit)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_time_range_batched", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_time_range_batched_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.limit = &limit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_time_range_batched(std::vector<std::vector<ThriftAssoc> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_time_range_batched") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_time_range_batched_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_time_range_batched failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void GraphQueryAggregatorServiceConcurrentClient::assoc_time_range_local(std::vector<ThriftAssoc> & _return, const int32_t shardId, const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  int32_t seqid = send_assoc_time_range_local(shardId, src, atype, tLow, tHigh, limit);
  recv_assoc_time_range_local(_return, seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_time_range_local(const int32_t shardId, const int64_t src, const int64_t atype, const int64_t tLow, const int64_t tHigh, const int32_t limit)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_time_range_local", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_time_range_local_pargs args;
  args.shardId = &shardId;
  args.src = &src;
  args.atype = &atype;
  args.tLow = &tLow;
  args.tHigh = &tHigh;
  args.limit = &limit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void GraphQueryAggregatorServiceConcurrentClient::recv_assoc_time_range_local(std::vector<ThriftAssoc> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_time_range_local") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      GraphQueryAggregatorService_assoc_time_range_local_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_time_range_local failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t GraphQueryAggregatorServiceConcurrentClient::assoc_add(const int64_t src, const int64_t atype, const int64_t dst, const int64_t time, const std::string& attr)
{
  int32_t seqid = send_assoc_add(src, atype, dst, time, attr);
  return recv_assoc_add(seqid);
}

int32_t GraphQueryAggregatorServiceConcurrentClient::send_assoc_add(const int64_t src, const int64_t atype, const int64_t dst, const int64_t time, const std::string& attr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("assoc_add", ::apache::thrift::protocol::T_CALL, cseqid);

  GraphQueryAggregatorService_assoc_add_pargs args;
  args.src = &src;
  args.atype = &atype;
  args.dst = &dst;
  args.time = &time;
  args.attr = &attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t GraphQueryAggregatorServiceConcurrentClient::recv_assoc_add(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("assoc_add") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      GraphQueryAggregatorService_assoc_add_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "assoc_add failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}



